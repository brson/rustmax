# Language features

[topics.ownership]
name = "Ownership"
aliases = ["move semantics", "owned values", "ownership system"]
category = "lang"
tags = ["memory-safety", "core-concept"]
brief = "Rust's system for managing memory through ownership rules"
relations = [
    { kind = "related", target = "borrowing" },
    { kind = "related", target = "lifetimes" },
    { kind = "related", target = "move-semantics" },
]

[topics.borrowing]
name = "Borrowing"
aliases = ["borrow", "references", "shared reference", "mutable reference"]
category = "lang"
tags = ["memory-safety", "core-concept"]
brief = "Temporarily accessing data without taking ownership"
relations = [
    { kind = "related", target = "ownership" },
    { kind = "related", target = "lifetimes" },
]

[topics.lifetimes]
name = "Lifetimes"
aliases = ["lifetime", "'a", "'static", "lifetime elision", "lifetime annotations"]
category = "lang"
tags = ["memory-safety", "core-concept"]
brief = "Annotations that tell the compiler how long references are valid"
relations = [
    { kind = "related", target = "borrowing" },
    { kind = "related", target = "ownership" },
]

[topics.move-semantics]
name = "Move Semantics"
aliases = ["move", "moved value", "value moved"]
category = "lang"
tags = ["memory-safety", "core-concept"]
brief = "Transferring ownership of a value from one binding to another"
relations = [
    { kind = "related", target = "ownership" },
    { kind = "contrast", target = "copy-trait" },
]

[topics.traits]
name = "Traits"
aliases = ["trait", "trait bounds", "impl trait", "dyn trait", "trait objects"]
category = "lang"
tags = ["core-concept", "polymorphism"]
brief = "Shared behavior definitions, similar to interfaces"
relations = [
    { kind = "related", target = "generics" },
    { kind = "related", target = "trait-objects" },
]

[topics.generics]
name = "Generics"
aliases = ["generic", "type parameters", "generic types", "parametric polymorphism"]
category = "lang"
tags = ["core-concept", "polymorphism"]
brief = "Writing code that works with multiple types"
relations = [
    { kind = "related", target = "traits" },
    { kind = "related", target = "monomorphization" },
]

[topics.monomorphization]
name = "Monomorphization"
aliases = ["monomorphize", "generic instantiation", "static dispatch"]
category = "lang"
tags = ["compilation", "polymorphism"]
brief = "Generating specialized code for each concrete type at compile time"
relations = [
    { kind = "related", target = "generics" },
    { kind = "contrast", target = "trait-objects" },
]

[topics.trait-objects]
name = "Trait Objects"
aliases = ["dyn", "dynamic dispatch", "dyn Trait", "vtable"]
category = "lang"
tags = ["polymorphism"]
brief = "Runtime polymorphism through dynamic dispatch"
relations = [
    { kind = "related", target = "traits" },
    { kind = "contrast", target = "impl-trait" },
]

[topics.impl-trait]
name = "impl Trait"
aliases = ["opaque types", "existential types"]
category = "lang"
tags = ["polymorphism"]
brief = "Static dispatch with hidden concrete types"
relations = [
    { kind = "related", target = "traits" },
    { kind = "contrast", target = "trait-objects" },
]

[topics.pattern-matching]
name = "Pattern Matching"
aliases = ["match", "if let", "let else", "patterns", "destructuring"]
category = "lang"
tags = ["core-concept"]
brief = "Destructuring and branching on the shape of data"
relations = [
    { kind = "related", target = "enums" },
    { kind = "related", target = "option" },
    { kind = "related", target = "result" },
]

[topics.enums]
name = "Enums"
aliases = ["enum", "algebraic data types", "ADT", "sum types", "variants"]
category = "lang"
tags = ["core-concept"]
brief = "Types with a fixed set of variants, each potentially holding data"
relations = [
    { kind = "related", target = "pattern-matching" },
    { kind = "related", target = "option" },
    { kind = "related", target = "result" },
]

[topics.option]
name = "Option"
aliases = ["Option<T>", "Some", "None", "nullable", "optional values"]
category = "lang"
tags = ["core-concept", "error-handling"]
brief = "Representing optional values without null"
relations = [
    { kind = "related", target = "result" },
    { kind = "related", target = "pattern-matching" },
]

[topics.result]
name = "Result"
aliases = ["Result<T, E>", "Ok", "Err", "error handling"]
category = "lang"
tags = ["core-concept", "error-handling"]
brief = "Representing success or failure with error information"
relations = [
    { kind = "related", target = "option" },
    { kind = "related", target = "question-mark-operator" },
    { kind = "related", target = "error-handling" },
]

[topics.question-mark-operator]
name = "? Operator"
aliases = ["question mark", "try operator", "error propagation", "?"]
category = "lang"
tags = ["error-handling"]
brief = "Propagating errors up the call stack concisely"
relations = [
    { kind = "related", target = "result" },
    { kind = "related", target = "option" },
    { kind = "related", target = "error-handling" },
]

[topics.closures]
name = "Closures"
aliases = ["closure", "lambda", "anonymous function", "Fn", "FnMut", "FnOnce"]
category = "lang"
tags = ["core-concept"]
brief = "Anonymous functions that capture their environment"
relations = [
    { kind = "related", target = "iterators" },
    { kind = "related", target = "traits" },
]

[topics.iterators]
name = "Iterators"
aliases = ["iterator", "Iterator trait", "IntoIterator", "iter", "into_iter"]
category = "lang"
tags = ["core-concept"]
brief = "Lazy sequences with chainable transformation methods"
relations = [
    { kind = "related", target = "closures" },
    { kind = "implements", target = "itertools" },
]

[topics.async-await]
name = "Async/Await"
aliases = ["async", "await", "async fn", ".await", "asynchronous"]
category = "lang"
tags = ["async", "core-concept"]
brief = "Language support for asynchronous programming"
relations = [
    { kind = "related", target = "futures" },
    { kind = "related", target = "pinning" },
    { kind = "implements", target = "tokio" },
]

[topics.futures]
name = "Futures"
aliases = ["Future", "future", "Poll", "async runtime"]
category = "lang"
tags = ["async"]
brief = "Values representing asynchronous computations"
relations = [
    { kind = "related", target = "async-await" },
    { kind = "related", target = "pinning" },
    { kind = "implements", target = "futures-crate" },
]

[topics.pinning]
name = "Pinning"
aliases = ["Pin", "Unpin", "pin", "self-referential"]
category = "lang"
tags = ["async", "advanced"]
brief = "Guaranteeing a value won't move in memory"
relations = [
    { kind = "related", target = "async-await" },
    { kind = "related", target = "futures" },
]

[topics.unsafe-rust]
name = "Unsafe Rust"
aliases = ["unsafe", "raw pointers", "unsafe block", "unsafe fn"]
category = "lang"
tags = ["advanced", "systems"]
brief = "Opting out of Rust's safety guarantees for low-level control"
relations = [
    { kind = "related", target = "ffi" },
    { kind = "related", target = "raw-pointers" },
]

[topics.macros]
name = "Macros"
aliases = ["macro", "macro_rules", "declarative macros", "macros by example"]
category = "lang"
tags = ["metaprogramming"]
brief = "Code that generates code at compile time"
relations = [
    { kind = "related", target = "proc-macros" },
    { kind = "related", target = "derive" },
]

[topics.proc-macros]
name = "Procedural Macros"
aliases = ["proc macro", "procedural macro", "derive macro", "attribute macro"]
category = "lang"
tags = ["metaprogramming", "advanced"]
brief = "Rust code that manipulates the token stream at compile time"
relations = [
    { kind = "related", target = "macros" },
    { kind = "related", target = "derive" },
    { kind = "implements", target = "syn" },
    { kind = "implements", target = "quote" },
]

[topics.derive]
name = "Derive"
aliases = ["#[derive]", "derive macro", "auto-derive"]
category = "lang"
tags = ["metaprogramming"]
brief = "Automatically implementing traits for types"
relations = [
    { kind = "related", target = "proc-macros" },
    { kind = "related", target = "traits" },
]

[topics.modules]
name = "Modules"
aliases = ["mod", "module", "visibility", "pub", "use", "crate structure"]
category = "lang"
tags = ["organization"]
brief = "Organizing code into namespaces and controlling visibility"
relations = [
    { kind = "related", target = "crates" },
]

[topics.crates]
name = "Crates"
aliases = ["crate", "package", "library crate", "binary crate"]
category = "lang"
tags = ["organization"]
brief = "Compilation units and packages in Rust"
relations = [
    { kind = "related", target = "modules" },
    { kind = "related", target = "cargo" },
]

[topics.copy-trait]
name = "Copy Trait"
aliases = ["Copy", "copy semantics", "bitwise copy"]
category = "lang"
tags = ["core-concept"]
brief = "Types that can be duplicated by simple bit copying"
relations = [
    { kind = "related", target = "clone-trait" },
    { kind = "contrast", target = "move-semantics" },
]

[topics.clone-trait]
name = "Clone Trait"
aliases = ["Clone", "clone", "deep copy"]
category = "lang"
tags = ["core-concept"]
brief = "Explicitly duplicating values"
relations = [
    { kind = "related", target = "copy-trait" },
]

[topics.send-sync]
name = "Send and Sync"
aliases = ["Send", "Sync", "thread safety", "marker traits"]
category = "lang"
tags = ["concurrency", "core-concept"]
brief = "Marker traits for thread-safe types"
relations = [
    { kind = "related", target = "concurrency" },
    { kind = "related", target = "threads" },
]

[topics.smart-pointers]
name = "Smart Pointers"
aliases = ["Box", "Rc", "Arc", "RefCell", "Cell"]
category = "lang"
tags = ["memory"]
brief = "Types that act like pointers with additional capabilities"
relations = [
    { kind = "related", target = "ownership" },
    { kind = "related", target = "interior-mutability" },
]

[topics.interior-mutability]
name = "Interior Mutability"
aliases = ["RefCell", "Cell", "UnsafeCell", "interior mutable"]
category = "lang"
tags = ["memory", "advanced"]
brief = "Mutating data through shared references"
relations = [
    { kind = "related", target = "smart-pointers" },
    { kind = "related", target = "borrowing" },
]

[topics.raw-pointers]
name = "Raw Pointers"
aliases = ["*const T", "*mut T", "pointer", "raw pointer"]
category = "lang"
tags = ["unsafe", "systems"]
brief = "Unmanaged pointers without safety guarantees"
relations = [
    { kind = "related", target = "unsafe-rust" },
    { kind = "related", target = "ffi" },
]
