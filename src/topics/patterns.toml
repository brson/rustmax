# Rust idioms, patterns, and best practices

[topics.newtype-pattern]
name = "Newtype Pattern"
aliases = ["newtype", "wrapper type", "type wrapper"]
category = "pattern"
tags = ["type-safety"]
brief = "Wrapping a type to add semantics or implement foreign traits"
relations = [
    { kind = "related", target = "traits" },
]

[topics.builder-pattern]
name = "Builder Pattern"
aliases = ["builder", "fluent interface", "method chaining"]
category = "pattern"
tags = ["api-design"]
brief = "Constructing complex objects step by step"
relations = []

[topics.typestate-pattern]
name = "Typestate Pattern"
aliases = ["typestate", "state machine types", "compile-time state"]
category = "pattern"
tags = ["type-safety", "advanced"]
brief = "Encoding state machines in the type system"
relations = [
    { kind = "related", target = "generics" },
]

[topics.raii]
name = "RAII"
aliases = ["resource acquisition is initialization", "drop guard", "scope guard"]
category = "pattern"
tags = ["memory", "core-concept"]
brief = "Tying resource lifetime to variable scope"
relations = [
    { kind = "related", target = "ownership" },
]

[topics.cow-pattern]
name = "Clone-on-Write"
aliases = ["Cow", "copy on write", "Cow<str>", "Cow<[T]>"]
category = "pattern"
tags = ["performance"]
brief = "Deferring cloning until mutation is needed"
relations = [
    { kind = "related", target = "borrowing" },
    { kind = "related", target = "clone-trait" },
]

[topics.extension-trait-pattern]
name = "Extension Traits"
aliases = ["extension trait", "Ext trait", "adding methods"]
category = "pattern"
tags = ["api-design"]
brief = "Adding methods to foreign types via traits"
relations = [
    { kind = "related", target = "traits" },
]

[topics.sealed-trait-pattern]
name = "Sealed Traits"
aliases = ["sealed trait", "private trait", "mod sealed"]
category = "pattern"
tags = ["api-design"]
brief = "Preventing external implementations of a trait"
relations = [
    { kind = "related", target = "traits" },
]

[topics.entry-api]
name = "Entry API"
aliases = ["entry", "or_insert", "or_insert_with", "HashMap entry"]
category = "pattern"
tags = ["collections"]
brief = "Efficient insert-or-update operations on maps"
relations = [
    { kind = "related", target = "std-collections" },
]

[topics.iterator-chains]
name = "Iterator Chains"
aliases = ["method chaining", "iterator combinators", "functional style"]
category = "pattern"
tags = ["functional"]
brief = "Composing lazy transformations on sequences"
relations = [
    { kind = "related", target = "iterators" },
    { kind = "related", target = "closures" },
]

[topics.error-context]
name = "Error Context"
aliases = ["with_context", "context", "error wrapping", "error chain"]
category = "pattern"
tags = ["error-handling"]
brief = "Adding context to errors as they propagate"
relations = [
    { kind = "related", target = "error-handling" },
    { kind = "related", target = "anyhow" },
]

[topics.from-into-idiom]
name = "From/Into Idiom"
aliases = ["From impl", "Into conversion", "type conversion"]
category = "pattern"
tags = ["core-concept"]
brief = "Idiomatic type conversions with From and Into"
relations = [
    { kind = "related", target = "std-convert" },
    { kind = "related", target = "traits" },
]

[topics.deref-coercion]
name = "Deref Coercion"
aliases = ["Deref", "automatic dereferencing", "&String to &str"]
category = "pattern"
tags = ["core-concept"]
brief = "Automatic conversion through Deref implementations"
relations = [
    { kind = "related", target = "smart-pointers" },
    { kind = "related", target = "std-ops" },
]

[topics.default-trait-pattern]
name = "Default Trait"
aliases = ["Default", "default()", "Default::default"]
category = "pattern"
tags = ["core-concept"]
brief = "Providing sensible default values for types"
relations = [
    { kind = "related", target = "derive" },
    { kind = "related", target = "builder-pattern" },
]

[topics.drop-guard]
name = "Drop Guard"
aliases = ["scope guard", "defer", "cleanup on drop"]
category = "pattern"
tags = ["memory"]
brief = "Running cleanup code when a value goes out of scope"
relations = [
    { kind = "related", target = "raii" },
    { kind = "related", target = "ownership" },
]

[topics.phantom-type-pattern]
name = "Phantom Types"
aliases = ["PhantomData", "phantom type parameter", "zero-sized marker"]
category = "pattern"
tags = ["type-safety", "advanced"]
brief = "Using type parameters for compile-time checks without runtime cost"
relations = [
    { kind = "related", target = "std-marker" },
    { kind = "related", target = "generics" },
]

[topics.interior-mutability-pattern]
name = "Interior Mutability"
aliases = ["RefCell pattern", "Cell pattern", "shared mutability"]
category = "pattern"
tags = ["memory"]
brief = "Mutating data through shared references"
relations = [
    { kind = "related", target = "interior-mutability" },
    { kind = "related", target = "std-cell" },
]

[topics.option-combinators]
name = "Option Combinators"
aliases = ["map", "and_then", "unwrap_or", "ok_or", "Option methods"]
category = "pattern"
tags = ["functional", "error-handling"]
brief = "Transforming and chaining Option values"
relations = [
    { kind = "related", target = "option" },
    { kind = "related", target = "iterator-chains" },
]

[topics.result-combinators]
name = "Result Combinators"
aliases = ["map_err", "and_then", "ok", "Result methods"]
category = "pattern"
tags = ["functional", "error-handling"]
brief = "Transforming and chaining Result values"
relations = [
    { kind = "related", target = "result" },
    { kind = "related", target = "question-mark-operator" },
]

[topics.thread-local-pattern]
name = "Thread-Local Storage"
aliases = ["thread_local!", "LocalKey", "thread local"]
category = "pattern"
tags = ["concurrency"]
brief = "Per-thread global state"
relations = [
    { kind = "related", target = "std-thread" },
    { kind = "related", target = "concurrency" },
]

[topics.once-cell-pattern]
name = "Lazy Initialization"
aliases = ["OnceLock", "LazyLock", "lazy_static", "once_cell"]
category = "pattern"
tags = ["concurrency"]
brief = "Initializing global state exactly once"
relations = [
    { kind = "related", target = "std-sync" },
    { kind = "related", target = "concurrency" },
]

[topics.send-wrapper]
name = "Send Wrapper"
aliases = ["SendWrapper", "making types Send"]
category = "pattern"
tags = ["concurrency", "advanced"]
brief = "Wrapping non-Send types for use across threads"
relations = [
    { kind = "related", target = "send-sync" },
]

[topics.pinning-pattern]
name = "Pin Projection"
aliases = ["pin projection", "pin-project", "structural pinning"]
category = "pattern"
tags = ["async", "advanced"]
brief = "Safely accessing fields of pinned structs"
relations = [
    { kind = "related", target = "pinning" },
    { kind = "related", target = "async-await" },
]

[topics.cancellation-pattern]
name = "Cancellation"
aliases = ["CancellationToken", "abort", "graceful shutdown"]
category = "pattern"
tags = ["async"]
brief = "Stopping async tasks gracefully"
relations = [
    { kind = "related", target = "async-await" },
    { kind = "related", target = "tokio" },
]

[topics.select-pattern]
name = "Select Pattern"
aliases = ["tokio::select", "futures::select", "racing futures"]
category = "pattern"
tags = ["async"]
brief = "Waiting on multiple futures simultaneously"
relations = [
    { kind = "related", target = "async-await" },
    { kind = "related", target = "tokio" },
]
