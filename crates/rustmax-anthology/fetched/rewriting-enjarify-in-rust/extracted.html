<article><div class="m"><div class="m"><span class="m"></span><section><div><div class="fw gz ha hb hc hd"></div><div class="he hf hg hh hi"><div class="ac ci"><div class="cp bi gq gr gs gt"><div><h1 class="pw-post-title hj hk hl bg hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il bl" data-testid="storyTitle" id="cf91">My experience rewriting Enjarify in Rust</h1><div><div class="speechify-ignore ac cw"><div class="speechify-ignore bi m"><div class="ac im in io ip iq ir is it iu iv iw"><div class="ac r iw"><div class="ac ix"><div><div class="bn" role="tooltip"><div class="bf" tabindex="-1"><a data-discover="true" href="/@robertgrosse?source=post_page---byline--723089b406ad---------------------------------------" rel="noopener follow"><div class="m iy iz by ja jb"><div class="m fr"><img alt="Robert Grosse" class="m fk by bz ca de" data-testid="authorPhoto" height="32" loading="lazy" src="https://miro.medium.com/v2/resize:fill:64:64/0*B-x_DvC-Xf4GTx8k." width="32"><div class="jc by m bz ca fw o jd gk"></div></div></div></a></div></div></div></div><span class="bg b bh ab bl"><div class="je ac r"><div class="ac r jf"><div class="ac r"><div><div class="bn" role="tooltip"><div class="bf" tabindex="-1"><span class="bg b bh ab bl"><a class="ah ai aj fo al am an ao ap aq ar as at jg" data-discover="true" data-testid="authorName" href="/@robertgrosse?source=post_page---byline--723089b406ad---------------------------------------" rel="noopener follow">Robert Grosse</a></span></div></div></div></div><div class="jh bn"></div></div></div></span></div><div class="ac r ji"><span class="bg b bh ab eb"><div class="ac ag"><span data-testid="storyReadTime">20 min read</span><div aria-hidden="true" class="jj jk m"><span aria-hidden="true" class="m"><span class="bg b bh ab eb">·</span></span></div><span data-testid="storyPublishDate">Sep 19, 2016</span></div></span></div></div><div class="ac cw jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka"><div class="i l x fp fq r"><div class="kq m"><div class="ac r kr ks"><div class="pw-multi-vote-icon fr kt ku kv kw"><span data-dd-action-name="Susi presentation tracker clap_footer"><a class="ah ai aj fo al am an ao ap aq ar as at au av" data-discover="true" data-testid="headerClapButton" href="/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Fp%2F723089b406ad&amp;operation=register&amp;redirect=https%3A%2F%2Fmedium.com%2F%40robertgrosse%2Fmy-experience-rewriting-enjarify-in-rust-723089b406ad&amp;user=Robert+Grosse&amp;userId=8963dc385f1f&amp;source=---header_actions--723089b406ad---------------------clap_footer------------------" rel="noopener follow"><div><div class="bn" role="tooltip"><div class="bf" tabindex="-1"><div class="kx aq ky kz la lb ao lc ld le kw" role="presentation"><svg aria-label="clap" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM13.916 3.953l1.523-2.112-1.184-.39zM8.589 1.84l1.522 2.112-.337-2.501zM18.523 18.92c-.86.86-1.75 1.246-2.62 1.33a6 6 0 0 0 .407-.372c2.388-2.389 2.86-4.951 1.399-7.623l-.912-1.603-.79-1.672c-.26-.56-.194-.98.203-1.288a.7.7 0 0 1 .546-.132c.283.046.546.231.728.5l2.363 4.157c.976 1.624 1.141 4.237-1.324 6.702m-10.999-.438L3.37 14.328a.828.828 0 0 1 .585-1.408.83.83 0 0 1 .585.242l2.158 2.157a.365.365 0 0 0 .516-.516l-2.157-2.158-1.449-1.449a.826.826 0 0 1 1.167-1.17l3.438 3.44a.363.363 0 0 0 .516 0 .364.364 0 0 0 0-.516L5.293 9.513l-.97-.97a.826.826 0 0 1 0-1.166.84.84 0 0 1 1.167 0l.97.968 3.437 3.436a.36.36 0 0 0 .517 0 .366.366 0 0 0 0-.516L6.977 7.83a.82.82 0 0 1-.241-.584.82.82 0 0 1 .824-.826c.219 0 .43.087.584.242l5.787 5.787a.366.366 0 0 0 .587-.415l-1.117-2.363c-.26-.56-.194-.98.204-1.289a.7.7 0 0 1 .546-.132c.283.046.545.232.727.501l2.193 3.86c1.302 2.38.883 4.59-1.277 6.75-1.156 1.156-2.602 1.627-4.19 1.367-1.418-.236-2.866-1.033-4.079-2.246M10.75 5.971l2.12 2.12c-.41.502-.465 1.17-.128 1.89l.22.465-3.523-3.523a.8.8 0 0 1-.097-.368c0-.22.086-.428.241-.584a.847.847 0 0 1 1.167 0m7.355 1.705c-.31-.461-.746-.758-1.23-.837a1.44 1.44 0 0 0-1.11.275c-.312.24-.505.543-.59.881a1.74 1.74 0 0 0-.906-.465 1.47 1.47 0 0 0-.82.106l-2.182-2.182a1.56 1.56 0 0 0-2.2 0 1.54 1.54 0 0 0-.396.701 1.56 1.56 0 0 0-2.21-.01 1.55 1.55 0 0 0-.416.753c-.624-.624-1.649-.624-2.237-.037a1.557 1.557 0 0 0 0 2.2c-.239.1-.501.238-.715.453a1.56 1.56 0 0 0 0 2.2l.516.515a1.556 1.556 0 0 0-.753 2.615L7.01 19c1.32 1.319 2.909 2.189 4.475 2.449q.482.08.971.08c.85 0 1.653-.198 2.393-.579.231.033.46.054.686.054 1.266 0 2.457-.52 3.505-1.567 2.763-2.763 2.552-5.734 1.439-7.586z" fill-rule="evenodd"></path></svg></div></div></div></div></a></span></div><div class="pw-multi-vote-count m lf lg lh li lj lk ll"><p class="bg b ec ab eb"><span class="lm">--</span></p></div></div></div><div><div class="bn" role="tooltip"><div class="bf" tabindex="-1"><button aria-label="responses" class="aq kx lp lq ac r fs lr ls"><svg class="lo" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"></path></svg><p class="bg b ec ab eb"><span class="pw-responses-count ln lo">12</span></p></button></div></div></div></div><div class="ac r kb kc kd ke kf kg kh ki kj kk kl km kn ko kp"><div class="lt l k j e"></div><div class="i l"><div><div class="bn" role="tooltip"><div class="bf" tabindex="-1"><span data-dd-action-name="Susi presentation tracker bookmark_footer"><a class="ah ai aj fo al am an ao ap aq ar as at au av" data-discover="true" data-testid="headerBookmarkButton" href="/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2F723089b406ad&amp;operation=register&amp;redirect=https%3A%2F%2Fmedium.com%2F%40robertgrosse%2Fmy-experience-rewriting-enjarify-in-rust-723089b406ad&amp;source=---header_actions--723089b406ad---------------------bookmark_footer------------------" rel="noopener follow"><svg aria-label="Add to list bookmark button" class="eb lu" fill="none" height="25" viewBox="0 0 25 25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M18 2.5a.5.5 0 0 1 1 0V5h2.5a.5.5 0 0 1 0 1H19v2.5a.5.5 0 1 1-1 0V6h-2.5a.5.5 0 0 1 0-1H18zM7 7a1 1 0 0 1 1-1h3.5a.5.5 0 0 0 0-1H8a2 2 0 0 0-2 2v14a.5.5 0 0 0 .805.396L12.5 17l5.695 4.396A.5.5 0 0 0 19 21v-8.5a.5.5 0 0 0-1 0v7.485l-5.195-4.012a.5.5 0 0 0-.61 0L7 19.985z" fill="currentColor"></path></svg></a></span></div></div></div></div><div class="fk lv cu"><div class="m ag"><div class="ac ci"><div class="lw lx ly lz ma mb cp bi"><div class="ac"><div class="bn" role="tooltip"><div><div class="bn" role="tooltip"><div class="bf" tabindex="-1"><button aria-label="Listen" class="ah fs aj fo al am an mc ap aq ar fe md me ls mf mg mh mi mj t mk ml mm mn mo mp mq v mr ms mt" data-testid="audioPlayButton"><svg fill="none" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" fill="currentColor" fill-rule="evenodd"></path></svg><div class="k j e"><p class="bg b bh ab eb">Listen</p></div></button></div></div></div></div></div></div></div></div></div><div aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu" class="bn"><div><div class="bn" role="tooltip"><div class="bf" tabindex="-1"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" class="ah fs aj fo al am an mc ap aq ar fe md me ls mf mg mh mi mj t mk ml mm mn mo mp mq v mr ms mt" data-testid="headerSocialShareButton"><svg fill="none" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path clip-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" fill="currentColor" fill-rule="evenodd"></path></svg><div class="k j e"><p class="bg b bh ab eb">Share</p></div></button></div></div></div></div></div></div></div></div></div></div><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="0b38">Last year I decided to rewrite Enjarify (a command line Python application) in Go and take notes in order to get data comparing the languages. Obviously, with a rewrite of an existing project, the resulting code won’t be as idiomatic as a project written from scratch, but I thought it was fair since Gophers are constantly trying to convert people away from Python for some reason, and doing a rewrite allows for a side by side comparison. Enjarify also has the advantage of end to end testing, making it easy to check that the implementations are in fact equivalent.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="cc7a">Anyway, the more I used Go, the more I hated it, and I ended up abandoning the project. Recently, I became interested in Rust, and decided to finish off the Go rewrite and rewrite Enjarify in Rust in order to get more experience with Rust and see if I would end up hating it like I did with Go. Below is my experience, as well as a comparison of the three versions.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="3509"><a class="ah ns" href="https://github.com/google/enjarify/tree/1ac4c5728eede44fa161c514aa946aa277490b99" rel="noopener ugc nofollow" target="_blank">All of the code discussed is available here.</a></p><h2 class="nt nu hl bg nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op oq bl" id="a901">Speed</h2><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="3c73">First off, a comparison of performance. For this, I ran Enjarify’s hashtests as a benchmark. This is a test that involves translating every test apk under every possible combination of options and hashing the results to detect regressions. I used CPython 3.4.3, Go 1.7, and Rust nightly (2016–09–02), all running on an i7–4790 with Linux.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="71cf">Note that this test measured single threaded performance. I noticed that under default settings, the Go version was using 130–160% CPU, despite the code not having any goroutines. I think this is because the garbage collector runs in a seperate goroutine started by the runtime. At any rate, I did the tests with GOMAXPROCS=1, leading to a slowdown of ~8% over the multithreaded version.</p><figure class="oz pa pb pc pd pe ow ox paragraph-image"><div class="ow ox oy"><picture><source sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 612px" srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/1*7HhieHh0kpFvUoExVLIGrg.png 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/1*7HhieHh0kpFvUoExVLIGrg.png 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/1*7HhieHh0kpFvUoExVLIGrg.png 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/1*7HhieHh0kpFvUoExVLIGrg.png 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/1*7HhieHh0kpFvUoExVLIGrg.png 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/1*7HhieHh0kpFvUoExVLIGrg.png 1100w, https://miro.medium.com/v2/resize:fit:1224/format:webp/1*7HhieHh0kpFvUoExVLIGrg.png 1224w" type="image/webp"><source data-testid="og" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 612px" srcset="https://miro.medium.com/v2/resize:fit:640/1*7HhieHh0kpFvUoExVLIGrg.png 640w, https://miro.medium.com/v2/resize:fit:720/1*7HhieHh0kpFvUoExVLIGrg.png 720w, https://miro.medium.com/v2/resize:fit:750/1*7HhieHh0kpFvUoExVLIGrg.png 750w, https://miro.medium.com/v2/resize:fit:786/1*7HhieHh0kpFvUoExVLIGrg.png 786w, https://miro.medium.com/v2/resize:fit:828/1*7HhieHh0kpFvUoExVLIGrg.png 828w, https://miro.medium.com/v2/resize:fit:1100/1*7HhieHh0kpFvUoExVLIGrg.png 1100w, https://miro.medium.com/v2/resize:fit:1224/1*7HhieHh0kpFvUoExVLIGrg.png 1224w"><img alt="" class="bi mb pf c" height="378" loading="eager" role="presentation" width="612"></picture></div><figcaption class="pg fm ph ow ox pi pj bg b bh ab eb">Hashtests time: Rust 135 seconds, Go 290 seconds, Python 1328 seconds</figcaption></figure><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="8365">Here is a chart showing the speedup over Python (i.e. the reciprocal of the above).</p><figure class="oz pa pb pc pd pe ow ox paragraph-image"><div class="ow ox pk"><picture><source sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 615px" srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/1*ZgZnyiEkjwA_EyH0THdXMg.png 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/1*ZgZnyiEkjwA_EyH0THdXMg.png 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/1*ZgZnyiEkjwA_EyH0THdXMg.png 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/1*ZgZnyiEkjwA_EyH0THdXMg.png 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/1*ZgZnyiEkjwA_EyH0THdXMg.png 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/1*ZgZnyiEkjwA_EyH0THdXMg.png 1100w, https://miro.medium.com/v2/resize:fit:1230/format:webp/1*ZgZnyiEkjwA_EyH0THdXMg.png 1230w" type="image/webp"><source data-testid="og" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 615px" srcset="https://miro.medium.com/v2/resize:fit:640/1*ZgZnyiEkjwA_EyH0THdXMg.png 640w, https://miro.medium.com/v2/resize:fit:720/1*ZgZnyiEkjwA_EyH0THdXMg.png 720w, https://miro.medium.com/v2/resize:fit:750/1*ZgZnyiEkjwA_EyH0THdXMg.png 750w, https://miro.medium.com/v2/resize:fit:786/1*ZgZnyiEkjwA_EyH0THdXMg.png 786w, https://miro.medium.com/v2/resize:fit:828/1*ZgZnyiEkjwA_EyH0THdXMg.png 828w, https://miro.medium.com/v2/resize:fit:1100/1*ZgZnyiEkjwA_EyH0THdXMg.png 1100w, https://miro.medium.com/v2/resize:fit:1230/1*ZgZnyiEkjwA_EyH0THdXMg.png 1230w"><img alt="" class="bi mb pf c" height="380" loading="lazy" role="presentation" width="615"></picture></div><figcaption class="pg fm ph ow ox pi pj bg b bh ab eb">Speedup: Rust: 9.8x, Go 4.6x, Python 1.0x</figcaption></figure><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="657f">Unsurprisingly, Python is slower than Go and Go is slower than Rust. However, I was surprised by just how big the gaps were, especially between Go and Rust. I guess all those lifetime annotations and long compile times really pay off. I think this does emphasize how Go isn’t quite on the same level of “systems” language as C++ and Rust are.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="ebbe">Before all the Gophers come out of the woodwork to say stuff like “you can avoid the heap in Go if you really try”, the Rust version is implementing more or less the same code, so it shouldn’t matter either way. I didn’t deliberately make the Go version inefficient — I just tried to write something equivalent to the original Python in the simplest and most natural way that each language supports. I expect that most of the gain in Rust comes from optimizations that are impossible or infeasible in Go due to features like lifetimes, immutability and generics, or things that would unacceptably increase compilation time in Go (i.e. LLVM). Besides, there’s still lots of room for optimization in the Rust version too.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="206c">^ Update: I spent a while trying to optimize the Go and Rust code and wrote a <a class="ah ns" data-discover="true" href="/@robertgrosse/parallelizing-enjarify-in-go-and-rust-21055d64af7e#.7vrcc2iaf" rel="noopener">follow up post</a> with the results.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="495f">Note: I was hoping to include Pypy in this comparison, but unfortunately, it was much slower than even CPython. Pypy 3 used to be several times faster than CPython, but it appears that performance fell off a cliff some time last year and still hasn’t recovered. I guess I should stop recommending that people use Pypy with Enjarify.</p><h2 class="nt nu hl bg nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op oq bl" id="d07e">Code Size</h2><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="e2b7">To measure code size, I stripped out comments and leading and trailing whitespace and added up the length of every nonempty line. I excluded generated code but included the code to generate that code. The script is <a class="ah ns" href="https://github.com/google/enjarify/blob/1ac4c5728eede44fa161c514aa946aa277490b99/loccount.py" rel="noopener ugc nofollow" target="_blank">here</a> if you want to see the exact methodology.</p><figure class="oz pa pb pc pd pe ow ox paragraph-image"><div class="ow ox pl"><picture><source sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 617px" srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/1*jjazB6bni06SjRrkv5eUQw.png 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/1*jjazB6bni06SjRrkv5eUQw.png 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/1*jjazB6bni06SjRrkv5eUQw.png 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/1*jjazB6bni06SjRrkv5eUQw.png 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/1*jjazB6bni06SjRrkv5eUQw.png 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/1*jjazB6bni06SjRrkv5eUQw.png 1100w, https://miro.medium.com/v2/resize:fit:1234/format:webp/1*jjazB6bni06SjRrkv5eUQw.png 1234w" type="image/webp"><source data-testid="og" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 617px" srcset="https://miro.medium.com/v2/resize:fit:640/1*jjazB6bni06SjRrkv5eUQw.png 640w, https://miro.medium.com/v2/resize:fit:720/1*jjazB6bni06SjRrkv5eUQw.png 720w, https://miro.medium.com/v2/resize:fit:750/1*jjazB6bni06SjRrkv5eUQw.png 750w, https://miro.medium.com/v2/resize:fit:786/1*jjazB6bni06SjRrkv5eUQw.png 786w, https://miro.medium.com/v2/resize:fit:828/1*jjazB6bni06SjRrkv5eUQw.png 828w, https://miro.medium.com/v2/resize:fit:1100/1*jjazB6bni06SjRrkv5eUQw.png 1100w, https://miro.medium.com/v2/resize:fit:1234/1*jjazB6bni06SjRrkv5eUQw.png 1234w"><img alt="" class="bi mb pf c" height="381" loading="lazy" role="presentation" width="617"></picture></div><figcaption class="pg fm ph ow ox pi pj bg b bh ab eb">Bytes of code: Rust 108847, Go 114180, Python 83013</figcaption></figure><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="2f86">Python, Rust, and Go had 2876, 3783, and 4971 lines of code respectively. The corresponding character counts are 83013, 108847, and 114180. I think the later is a better figure since it is less sensitive to brace style, but either way, the Rust code was larger than Python but smaller than Go.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="32f9">Unsurprisingly, Go is the most verbose. What Rust loses with lifetime annotations and big generic type signatures, it gains from the emphasis on ergonomics, and from having actual abstractions, instead of requiring you to copy paste code all the time. On the other hand, Rust is nowhere near Python in conciseness, which makes sense, since Python is a dynamically typed scripting language.</p><h2 class="nt nu hl bg nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op oq bl" id="688f">Development Time</h2><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="8277">The Go rewrite took somewhere around 45 hours to complete. The Rust rewrite took 49 hours. Note that these numbers are biased towards Rust, because I had the advantage of being able to consult both the Python and Go code while writing the Rust version and the advantage of having already solved some of the problems involved during the Go rewrite.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="9c42">I think a notable takeaway is that rewriting things takes longer than you expect, and that it takes a lot of time independent of the languages involved.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="f8c5">During the Rust rewrite, I spent a lot of time looking up the exact names and syntax of methods on Vec, Option, HashMap, etc. By contrast, with Go, there are no builtin methods at all. Some times I would do a web search to try to find the cleanest way to do something in Go, only to find out that there is no way and that you just have to brute force it with the limited tools available.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="a589">I also ran into several inscrutable lifetime/borrow errors, but that got easier as I went and accounted for only around two hours of wasted time total. I think the biggest time sink in Rust was a sort of death by a thousand cuts — all the time spent trying to get ampersands and refs in the right places, and other easily fixed, but extremely frequent, compiler errors.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="82d9">However, this does show that Rust’s infamous learning curve isn’t that bad, especially compared to the much touted simplicity of Go. Furthermore, becoming familiar with a language is basically a one time cost. I wouldn’t be surprised to find that if this experiment were done by someone who is expert in Go and Rust instead of a beginner, the Rust version would be completed faster than the Go version.</p><h2 class="nt nu hl bg nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op oq bl" id="3e96">Bugs</h2><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="e8cd">Since the original motivation for the rewrite was to compare Go and Python, I carefully kept track of the number of runtime bugs in the Go version to provide a bit of data for the perennial static vs dynamic typing debate, and figured I might as well do the same for Rust.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="bd74">The Go version had 50 bugs that were caught during testing after passing the compiler. This includes both trivial bugs as well as several bugs that each took 30+ minutes to debug. For Rust, the corresponding number is 29. This does not include 3 intentional integer overflows where I forgot to use wrapping operations, since that wouldn’t affect correctness of the release build. Cases where overflow represented an real bug are included in the 29.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="dac6">I hoped that Rust’s strong static typing would help reduce bugs, but sadly, it didn’t have much effect. A couple of the bugs I encountered in Go are completely impossible in Rust, but there were still a ton of bugs in the Rust version. Part of the problem is that bugs created while rewriting code are different from bugs that occur during normal coding. In this case, I was copying code that was already correct, so most of the bugs came from careless transcription mistakes which no type system could ever catch.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="bc11">There is one other way language affects the number of bugs however — the mental burden incurred while translating the code. For example, consider the following lines of Python.</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="eb14">        if isinstance(instr, ir.RegAccess) and not instr.store:<br>            used.add(instr.key)</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="83d2">In Rust, this became</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="1743">        if let ir::RegAccess(ref data) = instr.sub {<br>            if !data.store {<br>                used.insert(data.key);<br>            }<br>        }</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="89cf">However, I originally forgot to include the !data.store check, leading to a bug. The problem is that in Rust, there is no way to perform the required “downcast” as part of a larger expression*. After writing the outer if let, I went off to shave a yak and completely forgot to type the second half of the if condition. If downcasting were a simple expression I could type without interruption, that almost certainly wouldn’t have happened.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="f035">^ I later learned about match guards, which could probably handle that, but I wasn’t aware of them at the time.</p><h2 class="nt nu hl bg nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op oq bl" id="c6f1">Implementation Issues</h2><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="c638">There are a number of features in Python that require more involved translation into Go or Rust. Here’s an overview of how I handled them.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="a02d">Inheritance</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="0f84">Luckily, there are only two places in Enjarify that make nontrivial use of inheritance. The first, and easier case is ConstantPool.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="2369">There are two implementations of constant pools, SimpleConstantPool and SplitConstantPool. These are subclasses of an abstract base class, ConstantPool, which implements most of the functionality, while relying on a couple of abstract methods implemented by the subclasses.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="40db">In Go embedded structs cannot access the embedding struct so I had to create a struct for the base class, and an interface representing the methods implemented in the subclasses, then store that interface in the base struct. Then I created a struct for each of the subclasses embedding the base struct, and an interface representing the public interface of the whole thing. Plus all the wrapper methods required to implement the interfaces.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="55b2">Luckily, in Rust, default methods in traits can call non default methods of the trait, making it possible to directly simulate an abstract base class. The Rust version has just one trait and two implementing structs, nearly identical to the original Python. There were only a few minor downsides — first, traits can’t have fields, so I had to use an accessor method instead. Second, trait objects can’t have generic methods, so I couldn’t use Into for overloading (more about this later).</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="ebc0">The second, and much tougher case of inheritance is JvmInstruction. This has subclasses for various types of instruction (Label, RegAccess, PrimConstant, OtherConstant, Switch, and Other) as well as LazyJumpBase, which has two subclasses of its own (If and Goto). Additionally, the code makes heavy use of downcasting.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="231d">The Go version just replicated the Python inheritance hierarchy using interfaces and structs as before. However, this turned out to be a nightmare, and it’s not possible in Rust (without Any hacks) anyway. For the Rust version, I got rid of LazyJumpBase (duplicating the code it contained) and made JvmInstruction contain a giant enum.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="d3f3">There were a few annoyances to using an enum. The biggest problem is that it requires a lot of boilerplate and duplication. For example, here’s the enum definition that replaced (most of) JvmInstruction.</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="12a4">pub enum JvmInstructionSub {<br>    Label(LabelId),<br>    RegAccess(RAImpl),<br>    PrimConstant(PCImpl),<br>    OtherConstant,<br>    Goto(GotoImpl),<br>    If(IfImpl),<br>    Switch(SwitchImpl),<br>    Other,<br>}</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="86f7">If you want to be able to refer to the contents of the enum, have named fields*, or call methods, you need to create a separate struct definition. And that is in addition to the names of the enum constructors, leading to a ton of repetition.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="04dc">^ Correction: enum variants can have named fields.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="6d20">Apart from that, I needed to turn the methods that were defined in various subclasses into methods on JvmInstruction, with giant match statements over the contained enum. I also added helper methods like is_jump and is_constant since “isinstance” checks are a pain with the enum system.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="fd32">Exceptions</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="7898">Enjarify makes use of exceptions in two ways. The first is that if the generated bytecode is larger than the classfile limit, it throws an exception and retries translation with all the optimization options enabled. The second is that if any other exception is thrown while translating a class, it logs the error and continues with the next class, in order to handle invalid or malformed classes.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="a0a4">The good news is that Rust’s std::panic::catch_unwind/resume_unwind proved much easier to use than Go’s defer/recover. The bad news is that Rust prints out a stack trace when a panic first occurs rather than when a panic propagates to the top of the stack, so I had to set a custom panic hook to prevent that.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="82a1">Shared Mutability</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="81b1">One thing I was surprised by was how borrowck-friendly Enjarify was already, given that it was written in Python, where aliasing and mutability are natural. Most of the code required only minor modification to borrow check, but there were a couple harder cases.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="97d4">The first case was storing a (mutable) reference to the ConstantPool in IRWriter, which is kept alive until the entire class is done. The pool reference is only actually necessary while initially creating the IR, so I just split up and refactored the code, making it possible to borrow check. The result is cleaner, and it’s something I’d do to the Python version too if I had time, but it is notable that it required a big change to the code design.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="0207">The change of JvmInstruction from boxed to values and the removal of all uses of reference identity with it also removed another big source of aliasing.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="85b0">Another issue I ran into was with a recurring pattern where I iterate over all the instructions and mutate each one while examining the previous instruction or two. This doesn’t actually violate the alias rules, but there’s no way for the compiler to know that. Instead, I came up with a workaround. I created a local variable outside the loop which stores a copy of the relevant data from the previous instruction, and updated it and the end of the loop body.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="40ce">The last case is CopySetsMap. In this case, the shared mutability is necessary for the algorithm, so I just had to put everything in a Rc&lt;RefCell&gt; and endure the awful syntax resulting. At least it is only used in a very small part of the code. It’s a bit worrying though, since this is a very useful pattern, and I wish it was easier to do in Rust.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="ea9e">Reference Cycles</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="f164">Once again, I was surprised by how little the code actually relied on reference cycles. I was prepared to have to poorly simulate garbage collection with TypedArenas, but as it turns out, there were already no nontrivial reference cycles in the design.</p><h2 class="nt nu hl bg nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op oq bl" id="0f50">Pain Points in Rust</h2><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="eb05">While I didn’t end up hating Rust, I did run into a lot of annoyances. Hopefully, most of these will be fixed in the future.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="0546">Reference Syntax is Confusing</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="8c21">It is almost impossible to guess where you need &amp;s, refs, and so on, especially when dealing with iterator chaining and closures. If you can write code like this and have it compile on the first try, I will be very impressed.</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="7e0e">        let most_common: Vec&lt;_&gt; = {<br>            let mut most_common: Vec&lt;_&gt; = narrow_pairs.iter().collect();<br>            most_common.sort_by_key(|&amp;(ref p, &amp;count)| (-(count as i64), p.cmp_key()));<br>            most_common.into_iter().take(pool.lowspace()).map(|(ref p, count)| (*p).clone()).collect()<br>        };<br>        for k in most_common.into_iter() {<br>            narrow_pairs.remove(&amp;k);<br>            pool.insert_directly(k, true);<br>        }</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="38b1">Why do the &amp;s and *s and refs go where they do? ¯\_(ツ)_/¯</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="533e">Part of the problem is that auto-deref means you can get by without the right derefs in some circumstances, but in others, doing the same thing fails for no apparent reason.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="4709">To make matters worse, there’s a huge inconsistency with some methods taking references and others taking values. This actually makes sense when you think about it. For example, map insert() and entry() take ownership of the key because they may need to insert it, while remove(), [], contains_key(), etc. don’t need ownership and hence take references for maximum flexibility. However, it’s still an additional burden to contend with when starting out, especially when you’re just dealing with simple Copy types and shouldn’t have to care.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="993f">The compiler pretty much tells you what you need to change, but I wish I didn’t have to go through the edit -&gt; compile -&gt; edit -&gt; compile -&gt; success cycle so much in the first place. This is the death by a thousand cuts I mentioned above.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="729c">Explicit Integer Casts</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="3fca">All those integer casts are annoying in Go, and they’re annoying in Rust too. One of the problems is that it forces you to constantly choose between using an integer type that represents the actual range of values stored and using the type that is most convenient syntactically (i.e just using usize everywhere). Part of that is that most of the values Enjarify deals with are specifically limited to 16 or 32 bits due to the Dalvik file format. I imagine that for applications which don’t do binary file parsing, it is a lot less common to have values bounded a priori.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="26a7">I also wish that overflow semantics could be decoupled from storage size. Rust goes a long way towards this by requiring explicit wrapping operations when overflow is desired, but a full solution would probably require dependent types. Incidentally, I find it surprising that narrowing casts do not check for overflow. It seems like an oversight, though it might just be too hard to do in LLVM or something.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="9706">The worst part is that it seems to be ineffective at preventing bugs. There were several bugs in the Rust version related to integer casts. In one case, I called the wrong function, and it took a different width than the desired function. But it passed the compiler because I also forgot to cast the variables in question.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="c983">Besides, when nearly every call requires a cast, people will just automatically add them to shut the compiler up, defeating the purpose.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="5d91">Lifetime Subtype Syntax is Not Discoverable</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="f402">The combination of lifetime elision and automatic covariance deduction means that you rarely need more than one lifetime parameter. But in the case where you do, the syntax required is not discoverable.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="0fd4">For example, my IRBlock struct stores a mutable borrow of a ConstantPool object, but the references stored in the constant pool need to outlive the borrow, meaning that multiple lifetime parameters are required. Simply specifying multiple lifetime parameters isn’t hard. The part I found impossible was specifying that one of the lifetimes outlives another. It turns out that the syntax required is</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="8866">struct IRBlock&lt;'b, 'a: 'b&gt; {<br>    pool: &amp;'b mut (ConstantPool&lt;'a&gt; + 'a),<br>    // other fields omitted<br>}</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="c141">The extra bound and parenthesis on the trait object was confusing enough, but the ‘a: ‘b thing wasn’t mentioned in any of the tutorials or guides I could find. In fact, the only reason I figured it out was due to stumbling across it in a Stack Overflow question about a tangentially related topic (whether structs can have where clauses).</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="3ae0">Note that the usually helpful compiler is completely unhelpful here. It seems that the compiler suggestions are biased towards having as few lifetime parameters as possible, so if you mess up anything at all here, the resulting compiler error message will suggest removing the second lifetime parameter, which is obviously wrong in this case.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="90ba">Lack of Overloading</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="e53e">In Rust, it is idiomatic to use generic Into parameters to overload methods, but unfortunately, I couldn’t do this in either of the cases where it was most useful.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="10df">ConstantPool works with Cow&lt;bstr&gt; internally because there are rare cases where I need to store an owned string. But almost all callers will be passing &amp;bstr, so it would be nice to have methods accept that. Unfortunately, since ConstantPool is a trait object, generic methods can’t be used. I ended up prefixing the “internal” Cow methods with an underscore and creating “public” wrapper methods that take a &amp;bstr. But this is an ugly hack that shouldn’t be necessary.</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="945a">    fn _class(&amp;mut self, s: Cow&lt;'a, bstr&gt;) -&gt; u16 {<br>        let ind = self._utf8(s);<br>        self.get(Class(ArgsInd(ind)))<br>    }<br>    fn class(&amp;mut self, s: &amp;'a bstr) -&gt; u16 {self._class(s.into())}</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="7f47">Likewise, my TreePtr (a sparse persistent array implemented as a tree) uses usize for indexing internally, but the callers always use u16, so it would be nice to handle that. Unfortunately, usize inexplicably fails to implement From&lt;u16&gt;, so I once again was stuck with the underscore hack.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="d5a5">I guess the idea behind usize not being From&lt;u16&gt; is that Rust might some day support an 8 bit platform, but that is still insane. It’s silly to cause so much pain to everybody today in the hopes of not breaking code in the event of a speculative future platform. The worst part is that most Rust code won’t work on an 8 bit platform anyway. In fact, even the standard library itself implicitly assumes that usize &gt;= 32 bits, since Range&lt;u32&gt; implements ExactSizeIterator.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="04a9">Poor Bytestring Support</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="2c6f">Since most of the data Enjarify deals with is not utf8, I couldn’t use Rust’s native string types. Instead, I just defined type aliases for byte strings and used them everywhere.</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="f816">pub type BString = Vec&lt;u8&gt;;<br>pub type bstr = [u8];</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="cca4">This works reasonably well, mainly because I don’t do much string manipulation beyond slicing and concatenation. But on the rare occasions where I do, I really missed the string convenience methods, which aren’t defined for Vec&lt;u8&gt; or &amp;[u8]. Python by contrast, defines all the string methods for both unicode and byte strings. It also means that the default Debug implementation shows the values as a list of integers, rather than as strings.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="8ed7">On a side note, I never figured out how to make the compiler shut up about the naming of bstr, despite repeated searching. Nothing I try seems to work.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="bbe2">Update: The answer turns out to be #[allow(non_camel_case_types)]. I’m not sure how I missed that one. I did try several variations like #[allow(non_camel_case)], but I didn’t try putting _types at the end.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="e7fd">Reference Equality Is Verbose</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="9873">In Rust, everything uses value equality, which is usually what you want. But in the cases where you do want reference equality, it is unnecessarily verbose. There is no equivalent of Python’s is operator.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="32c5">That leads to code like</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="46c5">    pub fn is(&amp;self, rhs: &amp;Self) -&gt; bool {<br>        match (self.0.as_ref(), rhs.0.as_ref()) {<br>            (None, None) =&gt; true,<br>            (Some(r1), Some(r2)) =&gt; r1 as *const _ == r2 as *const _,<br>            _ =&gt; false<br>        }<br>    }</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="39fb">or even worse,</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="cd44">fn ptr(p: Option&lt;&amp;Rc&lt;RefCell&lt;CopySet&gt;&gt;&gt;) -&gt; *const CopySet {<br>    match p {<br>        Some(p) =&gt; p.deref().borrow().deref() as *const _,<br>        None =&gt; null(),<br>    }<br>}</span><span class="pr nu hl pn b ps ql pu m pv pw" id="c139">// ...</span><span class="pr nu hl pn b ps ql pu m pv pw" id="cd2b">        let s_set = ptr(self.0.get(&amp;src));<br>        let d_set = ptr(self.0.get(&amp;dest));<br>        if !s_set.is_null() &amp;&amp; s_set == d_set {<br>            // src and dest are copies of same value, so we can remove<br>            return false;<br>        }</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="f94f">Note: After writing this, I realized it could be simplified by just taking a pointer to the outer RefCell, but it’s still gratuitously complicated either way.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="5153">No Enum Subset Types</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="650e">When you have a value of enum type, it is treated as if it could be any variant of the enum, but often you statically know that it is a subset of the full enum. Usually this just causes a minor hassle with exhaustiveness checking, but it becomes a lot more annoying when the enum variants have different constraints.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="f79c">For example with the constantpool::Entry enum, the Utf8 variant stores a Cow&lt;’a, bstr&gt;, but every other variant just stores a couple of integers. Nevertheless, the enum has a whole suddenly requires a lifetime parameter everywhere and can no longer be Copy, even when it is statically known to not be a Utf8. The lifetime parameter issue can be worked around to some extent by just using ‘static lifetime in these places, but there is no way to magically make it Copy.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="bc35">Obviously, subset types would make the type system much more complicated, and I don’t even have any idea what kind of syntax you’d use to specify them. But it’s still a bit annoying.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="6d58">Match Exhaustiveness Checking Doesn’t Handle Integers</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="cd43">For some reason, even if you match on a u8 and cover every case from 0 to 255, you still have to add a _ =&gt; unreachable!() at the end to satisfy the compiler. I’m not sure why it’s not handled, but it kind of defeats the purpose of exhaustiveness checking. With an unreachable default case, there’s no compile time protection in the event that you legitimately missed a case. Apparently, this is a known issue but can’t be fixed because of backwards compatibility.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="c2b3">Lexical Lifetimes</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="8189">I know that Non Lexical Lifetimes are actively being worked on, but I figured I might as well highlight some cases where the limitations of the current borrow system caused awkward code.</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="ce1c">        let t = self.prims.get(src); self.prims.set(dest, t);<br>        let t = self.arrs.get(src); self.arrs.set(dest, t);<br>        let t = self.tainted.get(src); self.tainted.set(dest, t);</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="46f5">For example, here I had to split up the calls and assign it to a temporary variable. Lexical lifetimes prohibit the far more natural expression nesting, since the mutable borrow of the outer method call includes evaluation of the method arguments.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="fb50">I’m not sure if this is related, but I also ran into a weird issue where Box::borrow_mut() doesn’t work but a manual reborrow does. This one actually stumped me so much that I had to resort to <a class="ah ns" href="https://stackoverflow.com/questions/39339419/confusing-error-in-rust-with-trait-object-lifetime" rel="noopener ugc nofollow" target="_blank">asking on Stack Overflow.</a></p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="5175">Clone Arrays are not Clone</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="b50c">For some reason, arrays of T: Clone are not cloneable. It’s ridiculous that I have to write code like this</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="644a">fn clone&lt;T: Clone&gt;(src: &amp;[T; 16]) -&gt; [T; 16] {<br>    [src[0].clone(), src[1].clone(), src[2].clone(), src[3].clone(), src[4].clone(), src[5].clone(), src[6].clone(), src[7].clone(), src[8].clone(), src[9].clone(), src[10].clone(), src[11].clone(), src[12].clone(), src[13].clone(), src[14].clone(), src[15].clone()]<br>}</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="8b28">A similar issue makes it impossible to initialize a large array, forcing me to use a Vec inside SplitConstantPool, even though the data has a known, fixed length.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="1ebc">Missing Features</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="db27">I don’t know if I’m missing something*, but I couldn’t find any helper methods for copying or cloning elements in an Option or iterator chain. It can be solved with closures like .map(|x| x) (or its cousin .map(|ref x| x.clone())), but that just feels silly and unnecessary.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="f8a9">^ Update: <a class="ah ns" href="https://doc.rust-lang.org/core/option/enum.Option.html#method.cloned" rel="noopener ugc nofollow" target="_blank">I was missing something.</a></p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="3ccc">Likewise, it seems like Vec&lt;Option&lt;T&gt;&gt; -&gt; Vec&lt;T&gt;, removing all the None elements, would be a common task, but as far as I can tell, it still requires a verbose iter/filter/map/collect chain.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="5e22">^ Update: <a class="ah ns" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map" rel="noopener ugc nofollow" target="_blank">You can filter and map with a single call</a>.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="bac4">One other thing I missed is that there is no equivalent of Python’s int.bit_length(). Integers do have a leading_zeros() method, but without a way to get the corresponding width automatically, this is prone to mistakes. That is not an idle concern, because one of the 29 bugs I encountered was writing</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="bf2c">(64 - part63.leading_zeros())</span></pre><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="6cfc">For what turned out to be a 32 bit variable, rather than 64 bit like I thought.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="4728">Third Party Dependencies</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="5633">The Python and Go versions used only the standard library, but for the Rust version, I had to use a bunch of third party crates. Specifically, byteorder, getopts, lazy_static, rust-crypto, and zip. Cargo makes this very easy to do, but you still have to take the extra time to decide on a crate and read the documentation, and third party dependencies make me slightly nervous (cf. the left-pad fiasco).</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="4a22">Additionally, the zip crate only has basic functionality. For example, it might be useful to use a fixed timestamp for output jars to make the output deterministic. Python and Go support this, but the zip crate doesn’t appear to.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="7089">Whenever people said Go is batteries included or has a comprehensive standard library before, I’d always scoffed, since it is hard to take a standard library seriously when it doesn’t even have any collections, but now I can see what they mean. Rust has tons of useful collections and algorithms standard, but pretty much nothing else, while Go is the opposite. Python of course has both.</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="0efb">No try! for Option</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="031f">For the Rust version of the mutf8 decoder, I used custom iterator adapters. Iterators return Options, not Results, but unfortunately, there is no equivalent of the try! macro for Option. That meant that I had to copy paste the same four lines of code over and over, as you can see below.</p><pre class="oz pa pb pc pd pm pn po pp ak pq bl"><span class="pr nu hl pn b ps pt pu m pv pw" id="9210">impl&lt;'a&gt; Iterator for FixPairsIter&lt;'a&gt; {<br>    type Item = char;<br><br>    fn next(&amp;mut self) -&gt; Option&lt;char&gt; {<br>        let x = match self.0.next() {<br>            None =&gt; { return None; }<br>            Some(v) =&gt; v<br>        };<br>        if 0xD800 &lt;= x &amp;&amp; x &lt; 0xDC00 {<br>            let high = x - 0xD800;<br>            let low = match self.0.next() {<br>                None =&gt; { return None; }<br>                Some(v) =&gt; v<br>            } - 0xDC00;<br>            char::from_u32(0x10000 + (high &lt;&lt; 10) + (low &amp; 1023))<br>        } else {<br>            char::from_u32(x)<br>        }<br>    }<br>}</span></pre><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="676e">Debugging</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="d7a3">The default stack traces printed on panic are way too noisy. There’s typically a dozen stack frames in the guts of Rust at the top before it gets to the important part, the user code that triggered the panic. Also, there’s a lot of visual noise. It’s hard to find the important part, the file and line number, amidst all the random hex addresses. I wish Rust did what Python does and print out the relevant snippets of source code in the stack trace.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="a59e">Another annoyance is that even for debug modes, compilation takes a while (around 8 seconds for Enjarify) which is a big roadblock when you’re debugging in an edit-&gt;compile-&gt;run cycle. My ideal scenario would be a Python-like interpreter for debugging Rust, with no compilation required, and a nice REPL and pdb style debugger built in. (I guess I’m biased since I use Python so much).</p><h3 class="pr nu hl bg nv px py ef nz pz qa eh od nf qb qc qd nj qe qf qg nn qh qi qj qk bl" id="3444">Index is Broken</h3><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="038c">The Index trait is broken, because it requires returning a reference to the result, limiting it to collections that actually store a corresponding element. You can’t create and return values on the fly. This means that I couldn’t overload [] for Enjarify’s custom sparse array type and had to make do with get() and set() instead. This is a known issue, and I had already read about it before starting the rewrite, so I didn’t waste time attempting to implement Index, but it is still an annoyance.</p><h2 class="nt nu hl bg nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo op oq bl" id="71a0">Conclusion</h2><p class="pw-post-body-paragraph mu mv hl mw b mx or mz na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr he bl" id="db58">If you have a Python application and are considering rewriting it due to the siren song of static typing, you should seriously reconsider, at least if you have more tests than developers. Rewriting anything takes a lot of time and causes lots of bugs, going from Python to less expressive language means an increased maintenance burden. But if for some reason, you still want to rewrite it, please don’t pick Go. Rust is better in pretty much every way.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="408f">Apart from that, I hope that my experience shows the gaps that Rust still needs to fix.</p><p class="pw-post-body-paragraph mu mv hl mw b mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr he bl" id="0fc3"><em class="qm">The opinions expressed here are solely my own and do not represent my employer or any other organization.</em></p></div></div></div></div></section></div></div></article>