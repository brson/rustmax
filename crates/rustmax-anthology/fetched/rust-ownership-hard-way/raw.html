<!doctype html>
<html lang=en-AU>
<meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>Rust ownership, the hard way - an article by Chris Morgan</title>
<link rel=stylesheet href="https://chrismorgan.info/2019b.css?h=8ef8a8b9d956b8e1c02277deac7b4907c823ded256dbde5f8d84441d734494c7">
<link rel=stylesheet media="screen and (prefers-color-scheme: dark)" href="https://chrismorgan.info/2019b-dark.css?h=00ac53816cb79ed144d9337b4cd178f00f6eb721659e72a6e6d5bb2baec78119">
<link rel=alternate href="https://chrismorgan.info/feed.xml" type=application/atom+xml title="All blog posts by Chris Morgan">
<meta name=color-scheme content="light dark" id=schemer>
<meta name=theme-color content=#f71>
<meta name=author content="Chris Morgan">
<meta name=twitter:site content=@__chrismorgan>
<meta name=twitter:card content=summary>
<meta property=og:title content="Rust ownership, the hard way">
<meta name=description content="In order to truly understand Rust, one needs to understand its crucial differentiating feature: ownership. Let‚Äôs go through it in detail the hard way.">
<meta property=og:description content="In order to truly understand Rust, one needs to understand its crucial differentiating feature: ownership. Let‚Äôs go through it in detail the hard way.">
<details id=themer style=display:none>
	<summary aria-label=Theme title="Change theme (light/dark mode, serif/sans-serif font)"><b aria-hidden=true>üé® A<i>a</i></b></summary>
	<div><script>((e,t)=>{let a=e.querySelectorAll(t),r=e.currentScript.parentNode,c=(t,a,c,d,l,o)=>{let n,s=e.createElement("button"),m=()=>{o(n),s.childNodes[1].data=n?a:c;try{(localStorage.getItem(t)||n!=+l)&&localStorage.setItem(t,n)}catch(e){}};r.append(s),s.append("Switch to ","",d),s.addEventListener("click",()=>m(n=+!n));try{n=localStorage.getItem(t)}catch(e){}return m(n=+(n||l)),m},d=0;try{d=matchMedia("(prefers-color-scheme:dark)").matches}catch(e){}r.parentNode.style.display="",d=c("dark","light","dark"," theme",d,e=>(schemer.content=e?"dark":"light",a.forEach(t=>t.media=e?"screen":"not all"))),c("sans","serif","sans-serif"," body font",0,t=>e.documentElement.classList[t?"add":"remove"]("sans")),addEventListener("DOMContentLoaded",()=>{a=[...a,...e.querySelectorAll(t)],d()})})(document,'[media="screen and (prefers-color-scheme: dark)"]')</script></div>
</details>
<main class=has-trailer>
<article itemscope itemtype=http:&#x2F;&#x2F;schema.org&#x2F;Article>
<header class=header>
	<nav class=site-header>
		<h1><svg width=32 height=32 viewBox="0 0 226 226" fill=none stroke-linecap=round stroke-linejoin=round aria-hidden=true><path opacity=.5 stroke=#fff stroke-width=26 d="M149.9 78.6c-.8-.1.7-1.5 1.3-2 2-1.3 2.9.5 4.4 2.3 2.7 6 1.2 13-.6 19-.5.8-.7 1.7-1.3 2.5m-79.4-17c.5-4.8-2.8-4.6-4 1.5-1 6-2.7 12.9.5 18.5 1.4 1.9 3.3 1.7 5 2m49.5 16.5c-.7 3.3-.8 6-.6 9.6m-8.3-9.7c.3 3-1 6-.2 8.5m-8.7-5.6c1 1.1-.6 5.1.3 6.7m-9.6-5.4c.7-1 .7 2 1.3 3.2.2 1.7 0 3.5-.2 5.2m33.9-.4c-2 12.3-2.3 28.2-3 40.5-.1 6.7-.3 13.4-1.3 20m-11-46.8l.4 15.5c.4 11.8-.4 23.3-.2 34.5m-13.8-50.2c2.8 20.1 2.7 39.8 3.7 58.5m-17.4-71.4c3.6 18.6 2.6 38.7 6.9 55.8.4 2 .9 5.4 1 7.3m21.7-122.9c-.4 1 .5 1.6 1 2.8 2.4 6.2.8 13.3.2 19.8v.7M103 73.6c.2-.2.3-1.1.9.9 1.5 4.9 1.3 10 1 15.4-.4 4 1 7 .8 11M73.2 41.5a11 11 0 01.8-7.2c-.9-1.7 3-.9 2.9.9 1.7 3.2 2 7.2 4.4 10 3.2-2.3 4-6.7 5.8-10.1 1.7-3.6 3.3-8.5 7.5-9.7 2.2.7 3.3 3.3 4.7 5 1.2 2.2 1.8 5 4.7 5.1 5.5-1 7.2-7.6 11.8-10.2 1.7-2.2 3.6-.4 4.3 1.5-.2 3.3 1.7 6.3 2.7 9.3 3 2 6.3-1 8.7-3 3.8-2.8 7.3-7.7 12.5-7.5a8.5 8.5 0 011.8 5.8c.8 4.3 1.8 8.5 2.8 12.6m.8.1C147.8 59 147 75 146 89.8c-.4 19.2-1.2 38.4-3 57.6-1.4 6.7-1.7 13.6-2 20.5M72.3 42.5c2.5 10 2 22.6 3.9 32.8 2 17.7 3.1 35.6 4 53.5 1.3 9.3 1.5 18.4 3.2 28 1.1 3.4 1.3 8 1.5 11.6"/><path fill=#fff d="M72.4 36.8L76.7 81l-6.9 3.3-.6 17.6 10 5.5 5.7 60c13.6 28 18.8 45.8 33.4 32.5 8.5-7.8 14.5-7 22.6-32l5.3-58.3 9.6-11.3.8-19.1-9.5-2.6 2.2-33.2-5.9-17.5L125 36.5l-7.3-12.4L104 34.7l-10.4-9.2-11.8 17.6z"/><path stroke=#000 stroke-width=6 d="M149.9 78.6c-.8-.1.7-1.5 1.3-2 2-1.3 2.9.5 4.4 2.3 2.7 6 1.2 13-.6 19-.5.8-.7 1.7-1.3 2.5m-79.4-17c.5-4.8-2.8-4.6-4 1.5-1 6-2.7 12.9.5 18.5 1.4 1.9 3.3 1.7 5 2m49.5 16.5c-.7 3.3-.8 6-.6 9.6m-8.3-9.7c.3 3-1 6-.2 8.5m-8.7-5.6c1 1.1-.6 5.1.3 6.7m-9.6-5.4c.7-1 .7 2 1.3 3.2.2 1.7 0 3.5-.2 5.2m33.9-.4c-2 12.3-2.3 28.2-3 40.5-.1 6.7-.3 13.4-1.3 20m-11-46.8l.4 15.5c.4 11.8-.4 23.3-.2 34.5m-13.8-50.2c2.8 20.1 2.7 39.8 3.7 58.5m-17.4-71.4c3.6 18.6 2.6 38.7 6.9 55.8.4 2 .9 5.4 1 7.3m21.7-122.9c-.4 1 .5 1.6 1 2.8 2.4 6.2.8 13.3.2 19.8v.7M103 73.6c.2-.2.3-1.1.9.9 1.5 4.9 1.3 10 1 15.4-.4 4 1 7 .8 11M73.2 41.5a11 11 0 01.8-7.2c-.9-1.7 3-.9 2.9.9 1.7 3.2 2 7.2 4.4 10 3.2-2.3 4-6.7 5.8-10.1 1.7-3.6 3.3-8.5 7.5-9.7 2.2.7 3.3 3.3 4.7 5 1.2 2.2 1.8 5 4.7 5.1 5.5-1 7.2-7.6 11.8-10.2 1.7-2.2 3.6-.4 4.3 1.5-.2 3.3 1.7 6.3 2.7 9.3 3 2 6.3-1 8.7-3 3.8-2.8 7.3-7.7 12.5-7.5a8.5 8.5 0 011.8 5.8c.8 4.3 1.8 8.5 2.8 12.6m.8.1C147.8 59 147 75 146 89.8c-.4 19.2-1.2 38.4-3 57.6-1.4 6.7-1.7 13.6-2 20.5M72.3 42.5c2.5 10 2 22.6 3.9 32.8 2 17.7 3.1 35.6 4 53.5 1.3 9.3 1.5 18.4 3.2 28 1.1 3.4 1.3 8 1.5 11.6"/></svg><strong><a href="https://chrismorgan.info/">Chris Morgan</a></strong> ‚Ä∫ <a href="https:&#x2F;&#x2F;chrismorgan.info&#x2F;blog&#x2F;">Blog</a></h1>
	</nav>
	<div class=main>
		<h1><strong>Rust ownership, the hard way</strong></h1>
		<p class=intro>In order to truly understand Rust, one needs to understand its crucial differentiating feature: ownership. Let‚Äôs go through it in detail the hard way.
	</div>
	<div class=metadata>
		<p>
		<strong>Tagged:</strong> <a href=https://chrismorgan.info/blog/tags/rust/ class=tag title="The Rust programming language">Rust</a><br>
		<strong>Published:</strong> <time itemprop=datePublished datetime=2015-05-12>May 12, 2015</time><br>
		<strong>Last updated:</strong> <time itemprop=dateUpdated datetime=2021-08-04>August 4, 2021</time>
		<p>This article is intended to teach beginners <soft-br></soft-br>about the Rust programming language. Displayed compiler output is from Rust 1.54.0.
	</div>
</header>
<p>This article is an introduction to Rust‚Äôs concept of ownership. It‚Äôs designed for someone who is already a programmer but who is not especially familiar (maybe even not at all familiar) with Rust. It doesn‚Äôt attempt to explain all the concepts it deals with, but for the most part it should be clear enough. If you‚Äôre a beginner you may also find that you don‚Äôt understand various parts of it; in such a case, you might like to hold the article while you go and learn more about them elsewhere; you‚Äôll find more value in coming back to this article after.
<p>This concept of ownership is the pivotal part of Rust; it‚Äôs the part that makes its combination of efficiency and safety possible. While the rest of Rust is pretty similar to what you‚Äôll find in <span class="sidenote-container numbered"><span class=sidenote-src>mainstream languages</span><span class=sidenote role=note><span class=sidenote-separator> [</span>OK, so pattern matching and algebraic data types aren‚Äôt widespread in C‚Äêstyle languages, but they‚Äôre conceptually simple.<span class=sidenote-separator>]</span></span></span>, these concepts of ownership and lifetimes are different from anything in any mainstream language, so it‚Äôs likely to be the part that you‚Äôll spend the longest trying to grok; if you don‚Äôt give up but persist, then when it all clicks, working in Rust will be a joy, and you‚Äôll have unlocked a marvellous ability to reason about code. You‚Äôll also probably wish you could transplant a lot of the aspects of Rust‚Äôs ownership model to other languages you deal with.<span class="sidenote-container numbered omitsource"><span class=sidenote-src></span><span class=sidenote role=note><span class=sidenote-separator> [</span>Seriously. The ownership model makes reasoning about many things <em>so</em> much easier, and I really <em>do</em> miss it when working in other languages.<span class=sidenote-separator>]</span></span></span>
<p>This article deals with the concepts and theory of ownership and lifetimes; it doesn‚Äôt provide much in the way of practical usage examples; those you can find elsewhere. But it does explain all the rules that go to make Rust‚Äôs ownership model what it is. (It <em>is</em> called ‚Äúthe hard way‚Äù for a reason.)
<p>Well, on with the first of our four rules:
<h2 id=rule-one><ol><li value=1>Each object can be used exactly once. When you use an object it is moved to the new location and is no longer usable in the old.</ol></h2>
<p><a href=#exceptions-to-single-use>Later on</a> we‚Äôll deal with a couple of features that make this model more palatable, but for now we‚Äôll skip them, considering it at the most basic level.
<figure><pre><code><b>struct</b> A {}

<b>fn</b> main() {
    <b>let</b> a = A {};
    <b>let</b> b = a;
    <b>let</b> c = a;
}
</code></pre></figure>
<!-- Output from rustc 1.54.0; omitted ‚Äúunused variable‚Äù warnings, ‚Äú; 2 warnings emitted‚Äù on the last line, and ‚ÄúFor more information about this error, try `rustc --explain E0382`.‚Äù at the very end. -->
<figure class=compiler-output><pre><samp><b><span class=ansi-red>error[E0382]</span>: use of moved value: `a`</b>
<b class=ansi-blue> --&gt;</b> &lt;anon&gt;:6:13
<b class=ansi-blue>  |</b>
<b class=ansi-blue>4 | </b>    let a = A {};
<b class=ansi-blue>  |         - move occurs because `a` has type `A`, which does not implement the `Copy` trait</b>
<b class=ansi-blue>5 | </b>    let b = a;
<b class=ansi-blue>  |         - value moved here</b>
<b class=ansi-blue>6 | </b>    let c = a;
<b class=ansi-blue>  | </b>        <b class=ansi-red>^ value used here after move</b>

<b><span class=ansi-red>error</span>: aborting due to previous error</b></samp></pre></figure>
<p>The <code>A</code> instance placed in the slot <code>a</code> is moved to <code>b</code>, rendering <code>a</code> unusable.
<h2><ol><li value=2>When an object passes out of scope, it is destroyed and is no longer usable.</ol></h2>
<p><em>Blocks</em>, delimited by <span class="sidenote-container numbered"><span class=sidenote-src>curly braces</span><span class=sidenote role=note><span class=sidenote-separator> [</span>But not to be confused with struct declarations like <code><b>struct</b> A {}</code> and struct literals like <code>A {}</code>, as seen in this next example.<span class=sidenote-separator>]</span></span></span>, introduce a new level of scope, and anything declared inside a block (e.g. the binding <code>x</code> in <code><b>let</b> x = y;</code>) will <span class="sidenote-container numbered"><span class=sidenote-src>live until the end of that block.</span><span class=sidenote role=note><span class=sidenote-separator> [</span>This was strictly true when I first wrote this article, but <em>non‚Äêlexical lifetimes</em> landed in Rust¬†1.31 in 2018: in certain situations objects can now be destroyed before the end of their containing lexical scope; but I don‚Äôt think this is the right article to delve into detail about it. Suffice it to say that although it makes Rust conceptutally more complex, it makes it do what you want (rather than producing a compiler error) more of the time.<span class=sidenote-separator>]</span></span></span>
<figure><pre><code><b>struct</b> A {}

<b>fn</b> main() {
    {
        <b>let</b> a = A {};
    }
    <b>let</b> b = a;
}
</code></pre></figure>
<p>This example won‚Äôt work, because <code>a</code> has fallen out of scope and been destroyed by the time we try to assign it to <code>b</code>:
<!-- Output from rustc 1.54.0. Omitted ‚ÄúFor more information about this error, try `rustc --explain E0425`.‚Äù at the end. -->
<figure class=compiler-output><pre><samp><b><span class=ansi-red>error[E0425]</span>: cannot find value `a` in this scope</b>
<b class=ansi-blue> --&gt;</b> &lt;anon&gt;:7:13
<b class=ansi-blue>  |</b>
<b class=ansi-blue>7 | </b>    let b = a;
<b class=ansi-blue>  | </b>            <b class=ansi-red>^ not found in this scope</b>

<b><span class=ansi-red>error</span>: aborting due to previous error</b></samp></pre></figure>
<aside class=sidenote>
	<p>There are seven ways of introducing variable bindings; all use patterns, and all but <code><b>let</b></code> introduce a new level of scope. They are: <code><b>let</b></code>; match branches; <code><b>for</b></code>; <code><b>if let</b></code>; <code><b>while let</b></code>; function arguments; and closure arguments.
</aside>
<p>When an object passes out of scope and is destroyed, if the type implements <a href=https://doc.rust-lang.org/std/ops/trait.Drop.html><code>Drop</code></a>, that destructor will be run. I won‚Äôt get into the details of destructors here. Types like <code><b>&amp;</b>T</code> and <code><b>&amp;mut </b>T</code> (immutable and mutable references) do not have destructors.
<h2><ol><li value=3>Blocks can produce a value which goes up one level of scope.</ol></h2>
<p>As a language feature, this is typically known as <em>expression orientation</em>, as distinct from <em>statement orientation</em>. It‚Äôs a fairly simple concept and will seem perfectly natural to users of languages like Ruby, though to users of languages like C++ and Python it may seem a little odd. (I came originally from a Python background; at first I thought it a gimmick useful only for skipping the word <code><b>return</b></code> on the last statement of a function, but I rapidly discovered it isn‚Äôt a gimmick at all; it‚Äôs a very useful feature, for all that it wouldn‚Äôt suit a language like Python.)
<p>The main rule is simple: the last expression in a block is the value that the block produces. (A block is thus an expression too.) There are a couple of other rules to deal with the corner cases:
<aside class=sidenote>
	<p>People with some Rust experience may be familiar with the explanation of an implied <code>()</code> after a semicolon at the end of a block; this is not accurate, <a href="https://play.rust-lang.org/?code=fn foo() -> i32 { return 0; () }">as this type checking error shows</a>. The reachability check is important as it allows things like a <code><b>return</b></code> statement at the end of a function that returns something other than unit (even though that <em>specific</em> thing is considered bad style).
</aside>
<ul>
    <li><p>An empty block produces <code>()</code> (<em>unit</em>).
	<li><p>If a block‚Äôs contents ends with a semicolon and the end of the block is reachable, the block produces <code>()</code>.
</ul>
<p>Here‚Äôs a simple example:
<figure><pre><code><b>let</b> a = {
    <i class=c>// ‚Ä¶ do anything we like ‚Ä¶</i>
    <span class=n>1</span>
};
</code></pre></figure>
<p>Here, <code>a</code> ends up storing the value <code class=n>1</code>. Given these rules, you can see that putting braces around an expression changes nothing, for at each added level the block contains only a single expression, which is then its own value. <span class="sidenote-container numbered"><span class=sidenote-src>Hence, <code><b>let</b> a = { { { { <span class=n>1</span> } } } };</code> and <code><b>let</b> a = <span class=n>1</span>;</code> are equivalent.</span><span class=sidenote role=note><span class=sidenote-separator> [</span>They‚Äôre actually not <em>quite</em> equivalent in general, for a block expression is an <em>rvalue</em>; thus <code>string[..].is_empty()</code> works, while <code>{¬†string[..]¬†}.is_empty()</code> doesn‚Äôt.<span class=sidenote-separator>]</span></span></span>
<p>In languages without this feature, the only type of block that produces a value (if you‚Äôll allow my sloppy terminology here) is a function; there, they have the <code><b>return</b></code> keyword to fill in this blank. (Rust also has the <code><b>return</b></code> keyword to make early return more convenient, but the language would work fine without it‚Äî‚Äãit‚Äôd just be harder to write some sorts of code.<!-- 2021-08-04: I‚Äôm not certain if this (that `return` could be removed without reducing the expressiveness of functions) is actually true at present; I *think* it is since the advent of non‚Äêlexical lifetimes (1.31), but I‚Äôm not certain. The Polonius borrow checker may affect the situation a bit too, though whether for better or worse I don‚Äôt know. Loops are the main fiddly bit. -->)
<figure><pre><code><b>fn</b> foo_the_c_way() -> <b>i32</b> {
    <b>return</b> <span class=n>1</span>;
}

<b>fn</b> foo_the_rust_way() -> <b>i32</b> {
    <span class=n>1</span>
}</code></pre></figure>
<p>Because of this paradigm of expression orientation, the concept of special <span class="sidenote-container numbered"><span class=sidenote-src><em>ternary expressions</em></span><span class=sidenote role=note><span class=sidenote-separator> [</span><code>condition ? a : b</code> in most languages;<soft-br></soft-br> <code>a <b>if</b> condition <b>else</b> b</code> in Python.<span class=sidenote-separator>]</span></span></span> is not necessary in Rust, for an <code><b>if</b></code> expression can do the job just fine:
<figure><pre><code><b>let</b> x = <b>if</b> a { b } <b>else</b> { c };

<b>let</b> x = <b>if</b> a {
    <i class=c>// ‚Ä¶ do things ‚Ä¶</i>
    b
} <b>else</b> {
    <i class=c>// ‚Ä¶ do things ‚Ä¶</i>
    c
};
</code></pre></figure>
<!-- A related bonus of not doing ternary expressions is that ? was left unused, and so from Rust 1.14 we got the ? operator for early return (https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator) without causing confusion or potential parser trouble. -->
<h2><ol><li value=4>All objects have a lifetime which constrains which scopes they may be moved out of.</ol></h2>
<p>Now we‚Äôre getting into the harder stuff, the biggest thing that‚Äôs unusual about Rust: lifetimes. Syntactically, a lifetime in Rust is any identifier with the prefix of a single quotation mark, e.g. <code><i class=s>'a</i></code>. Any name will do for a lifetime, but there is one special lifetime, <code><b class=s><i>'static</i></b></code>, which means that an object contains no non‚Äêstatic references. Most of the primitive types (<code><b>i32</b></code>, <code><b>bool</b></code>, <code><b>str</b></code>, <code>[T]</code>, <i>&amp;c.</i>) are static; those that are not are:
<ul>
	<li>Arrays (<code>[T; n]</code>) and slices (<code>[T]</code>) of non‚Äêstatic types;
	<li>Tuples with non‚Äêstatic members;
	<li>Non‚Äêstatic references, <i>viz.</i> any <code><b>&amp;</b>T</code> or <code><b>&amp;mut</b> T</code> except <code><b>&amp;<i class=s>'static</i></b> T</code> and <code><b>&amp;<i class=s>'static</i> mut</b> T</code>.
</ul>
<aside class=sidenote>
	<h3>Conventions</h3>
	<p>Just as there is a widespread convention for generic type parameters with no special significance to have names following the pattern <code>T</code>, <code>U</code>, <code>V</code>, <i>&amp;c.</i>, there is a convention for generic lifetime parameters in Rust to follow the pattern <code><i class=s>'a</i></code>, <code><i class=s>'b</i></code>, <code><i class=s>'c</i></code>, <i>&amp;c.</i>
	<p>It‚Äôs also common to give them more meaningful letters or snake_case names; for example, where a key‚Äêvalue pair might be <code>Pair&lt;K, V></code>, if you needed lifetime parameters corresponding to each of them individually (this is occasionally useful, though in a case like this they‚Äôll typically have the same lifetime) you might go for <code><i class=s>'k</i></code> and <code><i class=s>'v</i></code>.
</aside>
<h3>Lifetime positions in types</h3>
<p>There are four places where a lifetime can appear in a <em>type</em>:
<ul>
	<li><code><b>&amp;</b><i class=s>'a</i> Type</code>: the lifetime of an immutable reference;
	<li><code><b>&amp;</b><i class=s>'a</i> <b>mut</b> Type</code>: the lifetime of a mutable reference;
	<li><code>Type&lt;<i class=s>'a</i>></code>: a generic lifetime parameter on a type;
	<li><span class="sidenote-container numbered"><span class=sidenote-src><code><b>dyn</b> Trait + <i class=s>'a</i></code></span><span class=sidenote role=note><span class=sidenote-separator> [</span>Before Rust 1.27, this was spelled without the <code><b>dyn</b></code> keyword, called a <em><a href=https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#bare-trait-objects>bare trait object</a></em>; that syntax was subsequently deprecated and is <a href=https://github.com/rust-lang/rust/pull/83213>removed altogether in the 2021 edition</a>.<span class=sidenote-separator>]</span></span></span>: a trait object‚Äôs lifetime, as with generic bounds (dealt with below).
</ul>
<p>The first two are, I believe, fairly obvious; it‚Äôs clearly unsafe to have a reference to an object that has been freed. (By baking this into the language, we avoid the problem of <em>dangling pointers</em> that languages like C have.)
<p>The third is much the same, as all generic lifetime parameters will, somewhere down the way, be of one of the other types, and so it‚Äôs just a way of passing that constraint through the types, like this:
<figure><pre><code><b>struct</b> Ref&lt;<i class=s>'a</i>, T: <i class=s>'a</i>>(<b>&amp;</b><i class=s>'a</i> T);</code></pre></figure>
<p>As you can see, this <code>Ref</code> type is basically just a wrapper around an immutable reference; as the contained field is of that lifetime, clearly the containing structure may not live any longer than it and so it must have that lifetime also. (The <code>T: <i class=s>'a</i></code> part is a type bound, saying that the generic type <code>T</code> must live for at least <code><i class=s>'a</i></code>; without this it would not work, for as already discussed it clearly wouldn‚Äôt make sense to have a reference living longer than the object it refers to.)
<p>The fourth and final of these (<code><b>dyn</b> Trait + <i class=s>'a</i></code>) is, I think, the most interesting, and it‚Äôs worth spending a short time on trait objects, because the way in which they fit into this arrangement is <em>slightly</em> different from elsewhere.
<p>Trait objects are Rust‚Äôs form of safe and convenient <em>dynamic dispatch</em> (that‚Äôs what the <code><b>dyn</b></code> stands for); they allow you to store arbitrary types that satisfy a trait in the one type. Because of the potential difference in size of the types implementing a trait, trait objects are only usable through a reference of some form; the owned form is thus <code><b>Box</b>&lt;<b>dyn</b> Trait></code>, and for references you can have <code><b>&amp;dyn </b>Trait</code> and <code><b>&amp;mut dyn</b> Trait</code>. This is a very brief and wholly lacking explanation of trait objects; you can find documentation of them elsewhere; a detailed explanation is out of scope<!-- ha! --> for this article.
<p>As stated, a trait object may be of a variety of different types; what, then, is the lifetime of a trait object? The answer is that we must specify it, like <code><b>Box</b>&lt;<b>dyn</b> Trait + <b class=s><i>'static</i></b>></code>, indicating that the contained object must be <code><b class=s><i>'static</i></b></code>, and <code><b>&amp;</b><i class=s>'a</i> (<b>dyn</b> Trait + <i class=s>'a</i>)</code>, indicating that the contained object‚Äôs lifetime must be at least <code><i class=s>'a</i></code>. Now as it happens, some of these common cases like <code>+ <b class=s><i>'static</i></b></code> on a boxed trait object and the duplication of the <code><i class=s>'a</i></code> in the reference are taken care of as default trait bounds‚Äî‚Äã<code><b>Box</b>&lt;<b>dyn</b> Trait></code> is normally equivalent to <code><b>Box</b>&lt;<b>dyn</b> Trait + <b class=s><i>'static</i></b>></code> and <code><b>&amp;</b><i class=s>'a</i> <b>dyn</b> Trait</code> to <code><b>&amp;</b><i class=s>'a</i> (<b>dyn</b> Trait + <i class=s>'a</i>)</code>. <span class="sidenote-container numbered"><span class=sidenote-src><a href=https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md>RFC 599, on default object bounds</a>, treats the current rules on this subject more precisely.</span><span class=sidenote role=note><span class=sidenote-separator> [</span>RFC 599 was written before the invention of the <code><b>dyn</b></code> keyword, so you‚Äôll see the old‚Äêstyle <a href=https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#bare-trait-objects>bare trait object</a> syntax in that document.<span class=sidenote-separator>]</span></span></span>
<p>(Note that just as the lifetime on a trait object can be omitted due to <em>default object bounds</em>, lifetimes on the other three cases can also often be omitted; the current rules of lifetime elision are covered in <a href=https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md>RFC 141</a>.)
<p>But still you may wonder: why do trait object need a lifetime? I think it‚Äôs easiest to just give an example of something that would be bad if it were allowed to compile (<a href="https://play.rust-lang.org/?code=fn main() %7B%0A    let trait_object: %26dyn AsRef<str> %3D %7B%0A        let string %3D %22I am a String%22.to_owned();%0A        %26string%0A    };%0A    println!(%22The string is {:?}%22%2C trait_object.as_ref());%0A}">which it isn‚Äôt</a>):
<figure><pre><code><b>fn</b> main() {
    <b>let</b> trait_object: <b>&amp;dyn</b> AsRef&lt;<b>str</b>&gt; = {
        <b>let</b> string = <span class=s>"I am a String"</span>.to_owned();
        <b>&amp;</b>string
    };
    <i>println!</i>(<span class=s>"The string is <b>{:?}</b>"</span>, trait_object.as_ref());
}
</code></pre></figure>
<p>By the time execution gets to the <code><i>println!</i></code> statement, <code>string</code> has been freed, so if this were allowed to compile, <code>trait_object</code>, which points to the contents of <code>string</code>, would also thus be pointing to freed memory, which is emphatically a Bad Thing‚Ñ¢. To maintain memory safety, the boxed trait object cannot live longer than the string it contains a reference to.
<h3>Lifetime positions in generic bounds</h3>
<p>As shown very basically above, a lifetime can also appear in <em>type parameter bounds</em> and <em>lifetime parameter bounds</em>. Here are some more examples:
<figure><pre><code><b>struct</b> Ref&lt;<i class=s>'a</i>, T: SomeTrait + AnotherTrait + <mark><i class=s>'a</i></mark>&gt;(<b>&amp;</b><i class=s>'a</i> T);

<i class=c>// Suppose we have something that is reading values from a buffer and storing</i>
<i class=c>// the decoded values, which still contain references to parts of the original</i>
<i class=c>// buffer, into a vector. For maximal generality, we have *two* lifetimes,</i>
<i class=c>// though normally one would suffice (this is a poor example since it doesn‚Äôt</i>
<i class=c>// benefit from taking two lifetimes). The reference to the vector must not</i>
<i class=c>// outlive the vector and all its items, which must not outlive the buffer.</i>
<b>struct</b> DecodeResult&lt;<i class=s>'buf</i>: <mark><i class=s>'decoded</i></mark>, <i class=s>'decoded</i>, T: <mark><i class=s>'buf</i></mark>&gt; {
	buffer: <b>&amp;</b><i class=s>'buf</i> [<b>u8</b>],
	decoded: <b>&amp;</b><i class=s>'decoded</i> <b>mut</b> Vec&lt;T>,
}
</code></pre></figure>
<p>By type parameter bounds we mean the <code>T: <i class=s>'buf</i></code>, stating that the lifetime of the type <code>T</code> must be at least <code><i class=s>'buf</i></code> (it must live at least as long as the buffer).
<p>By lifetime parameter bounds we mean the <code><i class=s>'buf</i>: <i class=s>'decoded</i></code>, stating that the lifetime <code><i class=s>'buf</i></code> must be at least as long as (must satisfy the constraint) <code><i class=s>'decoded</i></code>. This is extremely rare and is typically only of any use when <a href=https://doc.rust-lang.org/nomicon/subtyping.html#variance>subtyping and variance gets involved</a>.
<p>Really, these sorts of bounds are very similar to the trait object bounds: because generics can be of arbitrary types, you will often need to stipulate a minimal lifetime in order to work with a type. In the <code>DecodeResult</code> example above, <code>T</code>‚Äôs lifetime must be constrained to be at least <code><i class=s>'decoded</i></code>, or else the reference in the <code>decoded</code> field would not be valid. Rust could infer this sort of thing, but it would lead to surprises in various areas, so it refrains from the attempt.
<h2 id=exceptions-to-single-use>Exceptions to ‚Äúeach object can be used exactly once‚Äù</h2>
<p>There; we‚Äôve covered the four basic rules. There remains still one point to explain. Earlier on I posited the simple rule that each object can be used exactly once; as I also said, this isn‚Äôt actually universally true. There are two exceptions to this rule.
<h3><ol><li>Copy and move semantics</li></h3>
<p>Objects of types with <em>move semantics</em> can only be used once, but this is not true of types with <em>copy semantics</em>.
<p>An object has <em>copy semantics</em> if it implements <a href=https://doc.rust-lang.org/std/marker/trait.Copy.html><code>Copy</code></a>. This means that a value of that type can be duplicated simply by copying the bytes of memory. <code><b>i32</b></code>, for example, is <code>Copy</code> because it‚Äôs just an arbitrary four bytes of data, entirely self‚Äêcontained, while <code><b>Box</b>&lt;T></code> is not because it involves a heap allocation that it must own and so a simple copy of the bytes would cause two objects to own the data at the same time, breaking all sorts of invariants and probably eating your laundry.
<p>In the <a href=#rule-one>first code example</a>‚Äôs error, we saw the explanatory note ‚Äúmove occurs because <code>a</code> has type <code>A</code>, which does not implement the <code>Copy</code> trait‚Äù. <code>A</code> has move semantics; suppose we now implement the <code>Copy</code> trait, like this:
<figure><pre><code><mark><i>#[derive(Clone, Copy)]</i></mark>
<b>struct</b> A {}

<b>fn</b> main() {
    <b>let</b> a = A {};
    <b>let</b> b = a;
    <b>let</b> c = a;
}
</code></pre>
<figcaption>
	<p class=sidenote><code><i>#[derive(X)]</i></code> means ‚Äúhey compiler, <soft-br></soft-br>I want to implement <code>X</code> for this type, <soft-br></soft-br>I just want the obvious implementation, <soft-br></soft-br>so can you please do it for me?‚Äù
	<p class=sidenote>The Rust documentation <a href=https://doc.rust-lang.org/std/clone/trait.Clone.html#derivable>explains deriving <code>Clone</code></a> and <a href=https://doc.rust-lang.org/std/marker/trait.Copy.html#how-can-i-implement-copy><code>Copy</code></a>.
</figcaption>
</figure>
<p>With the addition of the <code>Copy</code> implementation for <code>A</code>, it‚Äôs changed from having move semantics to having copy semantics, and so the code now compiles.
<p>There is one final matter in this exception to the rule worth mentioning: generics. If you work with a generic type, it will have move semantics unless you specify <code>Copy</code> in its bounds. In cases where you wish to copy the value, you might wish to use <a href=https://doc.rust-lang.org/std/clone/trait.Clone.html><code>Clone</code></a> instead, as it is more general (and all types that implement <code>Copy</code> implement <code>Clone</code>). Don‚Äôt worry about efficiency of cloning versus copying, either; unless the writer of the type explicitly went out of their way to do so (which they should <em>never</em> do), cloning and copying will perform identically when optimised.
<p>For more information on this topic, see the <a href=https://doc.rust-lang.org/std/marker/trait.Copy.html><code>Copy</code> docs</a>.
<h3><ol><li value=2>Reference reborrowing</ol></h3>
<p>A particularly notable example of a type with copy semantics is <code><b>&amp;</b>T</code>; you can have as many immutable references to an object alive as you like, so long as there are no mutable references to it at the same time. <code><b>&amp;mut</b> T</code>, however, has move semantics, for you‚Äôre not allowed to have more than one mutable reference in scope at a time.
<p>So then, why does this example <a href="https://play.rust-lang.org/?code=fn take_ref<T>(_: %26T) { }%0Afn take_mut<T>(_: %26mut T) { }%0Afn main() %7B%0A    let mut a %3D 6;%0A    %7B%0A        let a_ref %3D %26a;%0A        take_ref(a_ref);%0A        // Naturally this will work, for &T is Copy.%0A        take_ref(a_ref);%0A    }%0A    %7B%0A        let a_mut %3D %26mut a;%0A        take_mut(a_mut);%0A        // Surely a_mut should have been consumed by the line above?%0A        take_mut(a_mut);%0A    }%0A}">work</a>?
<figure><pre><code><b>fn</b> take_ref&lt;T&gt;(_: <b>&amp;</b>T) { }
<b>fn</b> take_mut&lt;T&gt;(_: <b>&amp;mut</b> T) { }
<b>fn</b> main() {
    <b>let mut</b> a = <span class=n>6</span>;
    {
        <b>let</b> a_ref = <b>&amp;</b>a;
        take_ref(a_ref);
        <i class=c>// Naturally this will work, for &amp;T is Copy.</i>
        take_ref(a_ref);
    }
    {
        <b>let</b> a_mut = <b>&amp;mut</b> a;
        take_mut(a_mut);
        <i class=c>// Surely a_mut should have been consumed by the line above?</i>
        take_mut(a_mut);
    }
}
</code></pre></figure>
<p>There is another exception in play here: reference reborrowing. Where we pass <code>a_mut</code> to a function, it effectively becomes <code><b>&amp;mut *</b>a_mut</code>. This does mean that for a time two mutable references to the same thing <em>exist</em> (one in the caller and one in the function called), but at no point are both <em>accessible</em>, so it‚Äôs OK.
<p>Note that this exception only applies in situations where the parameter is of the form <code><b>&amp;mut</b> T</code>; if it is a generic taken by value (e.g. <code><b>fn</b>&lt;T>(x: T)</code>) then a mutable reference you pass in will <em>not</em> be reborrowed automatically. You can still use the <code><b>&amp;mut *</b>x</code> incantation to manually reborrow it, however.
<h2>Summary</h2>
<p>Let‚Äôs list the main points once again:
<ol>
	<li><p>Each object can be used exactly once. When you use an object it is moved to the new location and is no longer usable in the old. (<code>Copy</code> and automatic reference reborrowing are the two exceptions that make this more palatable.)
    <li><p>When an object passes out of scope, it is destroyed and is no longer usable.
    <li><p>Blocks can produce a value which goes up one level of scope. (As a language feature, this is known as <em>expression orientation</em>.)
    <li><p>All objects have a lifetime which constrains which scopes they may be moved out of.
</ol>
<p>These points are all that you need to understand all of Rust‚Äôs ownership model. The rules are surprisingly simple, though you can quickly get to fairly complex interactions which make things harder to reason about. Don‚Äôt worry if you haven‚Äôt understood all of this; if you are trying to learn Rust, go and do some other things for a while and come back to the article again later and you‚Äôll probably find it makes more sense and you can understand how ownership and lifetimes work. When you finally get to that point, you‚Äôll love Rust‚Äôs unusual ownership model.

	<aside class=trailer>
		<p>Comments? Questions? Corrections? If you want to contact me about anything in this post, email me at <a href="mailto:me@chrismorgan.info">me@chrismorgan.info</a> or <a href=https://old.reddit.com/r/rust/http://chrismorgan.info/blog/rust-ownership-the-hard-way.html>discuss it on /r/rust</a>.
		<p>Looking for more? My <a href=/blog/rust-fizzbuzz/>article about FizzBuzz</a> is particularly relevant, dealing with these questions of ownership in a (slightly) practical context. If you‚Äôre a beginner, I suggest you also go through the <a href=https://doc.rust-lang.org/>official documentation</a> with things like its <a href=https://doc.rust-lang.org/book/README.html>book</a>. I have <a href=/blog/tags/rust/>a few more posts about Rust</a> too.

	</aside>
</article>
</main>
<footer>
	<section>
		<h3>About me</h3>
		<p>I‚Äôm <strong>Chris Morgan</strong>, a software developer by trade, dealing mostly with web things, and a Christian by life‚Äî‚Äãtalk to me about that at any time. You can contact me at <a href=mailto:me@chrismorgan.info>me@chrismorgan.info</a>.
	</section>
	<section>
		<h3>Hire me</h3>
		<p>I‚Äôm available for contract work, training and mentoring/tutoring. (I love teaching.) I specialise in Rust, everything web, performance, usability and accessibility. Remote, or in person in Australia and New Zealand. <a href=/hire-me/>Further details here.</a>
	</section>
	<nav>
		<h3>More blog posts</h3>
		<ul>
			<li><strong>Newer blog post:</strong> <br class=compact><a rel=next href=https:&#x2F;&#x2F;chrismorgan.info&#x2F;blog&#x2F;tween&#x2F;>Tween: a middleware library experiment</a> <br class=compact>(published¬†2016-06-01)
			<li><strong>Older blog post:</strong> <br class=compact><a rel=prev href=https:&#x2F;&#x2F;chrismorgan.info&#x2F;blog&#x2F;rust-cfg_attr&#x2F;>Quick tip: the <code><i>#[cfg_attr]</i></code> attribute</a> <br class=compact>(published¬†2015-04-22)
		</ul>
	</nav>
	<nav>
		<h3>Sitewide links</h3>
		<ul>
			<li><a href="https://chrismorgan.info/about/">More <strong>about me</strong></a>
			<li><a href="https://chrismorgan.info/blog/"><strong>Blog posts</strong> (primarily technical) that I have written</a>
		</ul>
	</nav>
	<div class=colophon>
		<h3>Colophon</h3>
		<p>I wrote all content on this site, and all illustrations, except as otherwise attributed. You may use my content elsewhere under the <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution</a> license, citing <em>Chris Morgan (<a href=mailto:me@chrismorgan.info>me@chrismorgan.info</a>)</em>.
		<p>I also designed and implemented this site.
	</div>
</footer>
<script type=module>function reflowSoftBrs(){Array.prototype.forEach.call(document.querySelectorAll("soft-br"),e=>{var n=e.parentNode,t=e.firstChild;while(n.tagName=="SPAN"||n.tagName=="A")n=n.parentNode;t&&e.removeChild(t),n.offsetHeight==(e.appendChild(t||(t=document.createElement("br"))),n.offsetHeight)||e.removeChild(t)})}reflowSoftBrs();let s;addEventListener("resize",()=>{clearTimeout(s);s=setTimeout(()=>{s=null,reflowSoftBrs()},50)})</script>
