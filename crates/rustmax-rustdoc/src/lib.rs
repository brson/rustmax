//! Custom rustdoc HTML renderer for rustmax documentation.
//!
//! This crate parses rustdoc JSON output and renders it to custom HTML,
//! providing an alternative frontend to the standard rustdoc output.

mod parse;
mod types;
mod render;
mod output;

pub use parse::{load_json, load_json_dir};
pub use types::{ModuleTree, RenderableItem};
pub use render::RenderContext;
pub use output::write_docs;

use rmx::prelude::*;
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// Configuration for documentation rendering.
#[derive(Debug, Clone)]
pub struct RenderConfig {
    /// Output directory for generated HTML.
    pub output_dir: PathBuf,
    /// Base URL for external crate documentation (e.g., "https://docs.rs").
    pub external_base_url: String,
    /// Whether to include private items in the documentation.
    pub include_private: bool,
    /// Crate version to display.
    pub crate_version: Option<String>,
}

impl Default for RenderConfig {
    fn default() -> Self {
        Self {
            output_dir: PathBuf::from("target/rmxdoc"),
            external_base_url: "https://docs.rs".to_string(),
            include_private: false,
            crate_version: None,
        }
    }
}

/// Main documentation builder.
pub struct RustDoc {
    /// The parsed rustdoc JSON crate data.
    pub krate: rustdoc_types::Crate,
    /// Rendering configuration.
    pub config: RenderConfig,
}

impl RustDoc {
    /// Load documentation from a rustdoc JSON file.
    pub fn from_json(path: &Path) -> AnyResult<Self> {
        let krate = parse::load_json(path)?;
        Ok(Self {
            krate,
            config: RenderConfig::default(),
        })
    }

    /// Load documentation from JSON bytes.
    pub fn from_bytes(json: &[u8]) -> AnyResult<Self> {
        let krate = parse::load_bytes(json)?;
        Ok(Self {
            krate,
            config: RenderConfig::default(),
        })
    }

    /// Set the output directory.
    pub fn output_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.config.output_dir = dir.into();
        self
    }

    /// Set the external documentation base URL.
    pub fn external_base_url(mut self, url: impl Into<String>) -> Self {
        self.config.external_base_url = url.into();
        self
    }

    /// Include private items in documentation.
    pub fn include_private(mut self, include: bool) -> Self {
        self.config.include_private = include;
        self
    }

    /// Set the crate version to display.
    pub fn crate_version(mut self, version: impl Into<String>) -> Self {
        self.config.crate_version = Some(version.into());
        self
    }

    /// Render the documentation to HTML.
    pub fn render(&self) -> AnyResult<()> {
        // Build a local index for intra-doc link resolution.
        let global_index = self.build_local_index();
        let ctx = render::RenderContext::new_with_index(&self.krate, &self.config, &global_index)?;
        output::write_docs(&ctx)
    }

    /// Build a local item index from this crate's paths.
    fn build_local_index(&self) -> GlobalItemIndex {
        let mut index = GlobalItemIndex::default();
        let crate_name = self.krate.index.get(&self.krate.root)
            .and_then(|item| item.name.clone())
            .unwrap_or_default();

        for (_id, summary) in &self.krate.paths {
            // Only index items from this crate (crate_id 0 means local).
            if summary.crate_id == 0 {
                let path = summary.path.join("::");
                index.items.insert(path.clone(), ItemLocation {
                    crate_name: crate_name.clone(),
                    path: summary.path.clone(),
                    kind: summary.kind,
                });
            }
        }

        index
    }
}

/// Documentation builder for multiple crates.
///
/// Use this when you want to render documentation for a crate and all its dependencies,
/// with cross-crate links working correctly.
pub struct RustDocSet {
    /// Map from crate name to parsed crate data.
    pub crates: HashMap<String, rustdoc_types::Crate>,
    /// Rendering configuration.
    pub config: RenderConfig,
}

impl RustDocSet {
    /// Load documentation from a directory containing rustdoc JSON files.
    ///
    /// The directory should contain `*.json` files generated by
    /// `RUSTDOCFLAGS="-Z unstable-options --output-format json" cargo +nightly doc`.
    pub fn from_json_dir(path: &Path) -> AnyResult<Self> {
        let crates = parse::load_json_dir(path)?;
        Ok(Self {
            crates,
            config: RenderConfig::default(),
        })
    }

    /// Set the output directory.
    pub fn output_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.config.output_dir = dir.into();
        self
    }

    /// Set the external documentation base URL.
    pub fn external_base_url(mut self, url: impl Into<String>) -> Self {
        self.config.external_base_url = url.into();
        self
    }

    /// Include private items in documentation.
    pub fn include_private(mut self, include: bool) -> Self {
        self.config.include_private = include;
        self
    }

    /// Render all crates to HTML.
    pub fn render(&self) -> AnyResult<()> {
        // Build global item index for cross-crate linking.
        let global_index = self.build_global_index();

        // Render each crate.
        for (crate_name, krate) in &self.crates {
            eprintln!("Rendering {}...", crate_name);
            let ctx = render::RenderContext::new_full(
                krate,
                &self.config,
                &global_index,
                &self.crates,
            )?;
            output::write_docs(&ctx)?;
        }

        Ok(())
    }

    /// Build a global index mapping item paths to their crate and URL.
    fn build_global_index(&self) -> GlobalItemIndex {
        let mut index = GlobalItemIndex::default();

        for (crate_name, krate) in &self.crates {
            // First pass: index canonical paths from krate.paths.
            for (_id, summary) in &krate.paths {
                if summary.crate_id == 0 {
                    let path = summary.path.join("::");
                    index.items.insert(path.clone(), ItemLocation {
                        crate_name: crate_name.clone(),
                        path: summary.path.clone(),
                        kind: summary.kind,
                    });
                }
            }

            // Second pass: find re-exports and index them.
            self.index_reexports(krate, crate_name, &mut index);

            // Third pass: index items from doc links.
            // This catches items re-exported via glob imports (like thiserror::Error).
            self.index_doc_links(krate, crate_name, &mut index);
        }

        index
    }

    /// Index items referenced in doc links.
    ///
    /// When docs contain links like `crate::thiserror::Error`, rustdoc resolves them
    /// and stores the mapping in the item's `links` field. We use this to index
    /// items that are re-exported via glob imports.
    fn index_doc_links(
        &self,
        krate: &rustdoc_types::Crate,
        crate_name: &str,
        index: &mut GlobalItemIndex,
    ) {
        for (_id, item) in &krate.index {
            for (link_text, target_id) in &item.links {
                // Only process crate:: links.
                let Some(relative_path) = link_text.strip_prefix("crate::") else {
                    continue;
                };

                // Look up the target in paths.
                let Some(path_info) = krate.paths.get(target_id) else {
                    continue;
                };

                // Build the full path as it would appear in this crate.
                let full_path = format!("{}::{}", crate_name, relative_path);

                // Only insert if not already present (prefer earlier passes).
                index.items.entry(full_path).or_insert_with(|| ItemLocation {
                    crate_name: crate_name.to_string(),
                    path: {
                        let mut path = vec![crate_name.to_string()];
                        path.extend(relative_path.split("::").map(String::from));
                        path
                    },
                    kind: path_info.kind,
                });
            }
        }
    }

    /// Index re-exports by walking the module tree and finding `use` items.
    fn index_reexports(
        &self,
        krate: &rustdoc_types::Crate,
        crate_name: &str,
        index: &mut GlobalItemIndex,
    ) {
        use rustdoc_types::ItemEnum;

        // Build a map from item ID to its parent module path.
        let mut item_to_parent_path: HashMap<&rustdoc_types::Id, Vec<String>> = HashMap::new();

        // Start from the root module.
        if krate.index.contains_key(&krate.root) {
            let root_path = vec![crate_name.to_string()];
            self.collect_module_paths(krate, &krate.root, &root_path, &mut item_to_parent_path);
        }

        // Now walk all items and find Use items.
        for (id, item) in &krate.index {
            if let ItemEnum::Use(use_item) = &item.inner {
                // Skip glob imports and primitive re-exports.
                if use_item.is_glob || use_item.id.is_none() {
                    continue;
                }

                // Skip non-public items.
                if item.visibility != rustdoc_types::Visibility::Public {
                    continue;
                }

                let target_id = use_item.id.as_ref().unwrap();

                // Get the kind and canonical path from paths if available.
                let Some(path_info) = krate.paths.get(target_id) else {
                    continue;
                };
                let kind = path_info.kind;

                // Skip if we can't determine a useful kind.
                if kind == rustdoc_types::ItemKind::Use {
                    continue;
                }

                // Build the re-export lookup path.
                if let Some(parent_path) = item_to_parent_path.get(id) {
                    let mut reexport_path = parent_path.clone();
                    reexport_path.push(use_item.name.clone());

                    let path_str = reexport_path.join("::");

                    // Use the re-export path for URL building since pages are generated there.
                    // Only insert if not already present (prefer canonical paths).
                    index.items.entry(path_str).or_insert_with(|| ItemLocation {
                        crate_name: crate_name.to_string(),
                        path: reexport_path,
                        kind,
                    });
                }
            }
        }
    }

    /// Recursively collect module paths for all items.
    fn collect_module_paths<'a>(
        &self,
        krate: &'a rustdoc_types::Crate,
        module_id: &'a rustdoc_types::Id,
        module_path: &[String],
        item_to_parent_path: &mut HashMap<&'a rustdoc_types::Id, Vec<String>>,
    ) {
        use rustdoc_types::ItemEnum;

        let Some(module_item) = krate.index.get(module_id) else {
            return;
        };

        let ItemEnum::Module(module) = &module_item.inner else {
            return;
        };

        // Record the parent path for all items in this module.
        for child_id in &module.items {
            item_to_parent_path.insert(child_id, module_path.to_vec());

            // Recurse into submodules.
            if let Some(child_item) = krate.index.get(child_id) {
                if let ItemEnum::Module(_) = &child_item.inner {
                    if let Some(name) = &child_item.name {
                        let mut child_path = module_path.to_vec();
                        child_path.push(name.clone());
                        self.collect_module_paths(krate, child_id, &child_path, item_to_parent_path);
                    }
                }
            }
        }
    }
}

/// Global index of items across all crates.
#[derive(Debug, Default)]
pub struct GlobalItemIndex {
    /// Map from full path (like "serde::Serialize") to item location.
    pub items: HashMap<String, ItemLocation>,
}

/// Location of an item in the documentation.
#[derive(Debug, Clone)]
pub struct ItemLocation {
    /// The crate this item belongs to.
    pub crate_name: String,
    /// Path components (e.g., ["serde", "Serialize"]).
    pub path: Vec<String>,
    /// The kind of item.
    pub kind: rustdoc_types::ItemKind,
}
