//! Custom rustdoc HTML renderer for rustmax documentation.
//!
//! This crate parses rustdoc JSON output and renders it to custom HTML,
//! providing an alternative frontend to the standard rustdoc output.

mod parse;
mod types;
mod render;
mod output;

pub use parse::{load_json, load_json_dir};
pub use types::{ModuleTree, RenderableItem};
pub use render::RenderContext;
pub use output::write_docs;

use rmx::prelude::*;
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// Configuration for documentation rendering.
#[derive(Debug, Clone)]
pub struct RenderConfig {
    /// Output directory for generated HTML.
    pub output_dir: PathBuf,
    /// Base URL for external crate documentation (e.g., "https://docs.rs").
    pub external_base_url: String,
    /// Whether to include private items in the documentation.
    pub include_private: bool,
    /// Crate version to display.
    pub crate_version: Option<String>,
}

impl Default for RenderConfig {
    fn default() -> Self {
        Self {
            output_dir: PathBuf::from("target/rmxdoc"),
            external_base_url: "https://docs.rs".to_string(),
            include_private: false,
            crate_version: None,
        }
    }
}

/// Main documentation builder.
pub struct RustDoc {
    /// The parsed rustdoc JSON crate data.
    pub krate: rustdoc_types::Crate,
    /// Rendering configuration.
    pub config: RenderConfig,
}

impl RustDoc {
    /// Load documentation from a rustdoc JSON file.
    pub fn from_json(path: &Path) -> AnyResult<Self> {
        let krate = parse::load_json(path)?;
        Ok(Self {
            krate,
            config: RenderConfig::default(),
        })
    }

    /// Load documentation from JSON bytes.
    pub fn from_bytes(json: &[u8]) -> AnyResult<Self> {
        let krate = parse::load_bytes(json)?;
        Ok(Self {
            krate,
            config: RenderConfig::default(),
        })
    }

    /// Set the output directory.
    pub fn output_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.config.output_dir = dir.into();
        self
    }

    /// Set the external documentation base URL.
    pub fn external_base_url(mut self, url: impl Into<String>) -> Self {
        self.config.external_base_url = url.into();
        self
    }

    /// Include private items in documentation.
    pub fn include_private(mut self, include: bool) -> Self {
        self.config.include_private = include;
        self
    }

    /// Set the crate version to display.
    pub fn crate_version(mut self, version: impl Into<String>) -> Self {
        self.config.crate_version = Some(version.into());
        self
    }

    /// Render the documentation to HTML.
    pub fn render(&self) -> AnyResult<()> {
        // Build a local index for intra-doc link resolution.
        let global_index = self.build_local_index();
        let ctx = render::RenderContext::new_with_index(&self.krate, &self.config, &global_index)?;
        output::write_docs(&ctx)
    }

    /// Build a local item index from this crate's paths.
    fn build_local_index(&self) -> GlobalItemIndex {
        let mut index = GlobalItemIndex::default();
        let crate_name = self.krate.index.get(&self.krate.root)
            .and_then(|item| item.name.clone())
            .unwrap_or_default();

        for (_id, summary) in &self.krate.paths {
            // Only index items from this crate (crate_id 0 means local).
            if summary.crate_id == 0 {
                let path = summary.path.join("::");
                index.items.insert(path.clone(), ItemLocation {
                    crate_name: crate_name.clone(),
                    path: summary.path.clone(),
                    kind: summary.kind,
                });
            }
        }

        index
    }
}

/// Documentation builder for multiple crates.
///
/// Use this when you want to render documentation for a crate and all its dependencies,
/// with cross-crate links working correctly.
pub struct RustDocSet {
    /// Map from crate name to parsed crate data.
    pub crates: HashMap<String, rustdoc_types::Crate>,
    /// Rendering configuration.
    pub config: RenderConfig,
}

impl RustDocSet {
    /// Load documentation from a directory containing rustdoc JSON files.
    ///
    /// The directory should contain `*.json` files generated by
    /// `RUSTDOCFLAGS="-Z unstable-options --output-format json" cargo +nightly doc`.
    pub fn from_json_dir(path: &Path) -> AnyResult<Self> {
        let crates = parse::load_json_dir(path)?;
        Ok(Self {
            crates,
            config: RenderConfig::default(),
        })
    }

    /// Set the output directory.
    pub fn output_dir(mut self, dir: impl Into<PathBuf>) -> Self {
        self.config.output_dir = dir.into();
        self
    }

    /// Set the external documentation base URL.
    pub fn external_base_url(mut self, url: impl Into<String>) -> Self {
        self.config.external_base_url = url.into();
        self
    }

    /// Include private items in documentation.
    pub fn include_private(mut self, include: bool) -> Self {
        self.config.include_private = include;
        self
    }

    /// Render all crates to HTML.
    pub fn render(&self) -> AnyResult<()> {
        // Build global item index for cross-crate linking.
        let global_index = self.build_global_index();

        // Render each crate.
        for (crate_name, krate) in &self.crates {
            eprintln!("Rendering {}...", crate_name);
            let ctx = render::RenderContext::new_with_index(
                krate,
                &self.config,
                &global_index,
            )?;
            output::write_docs(&ctx)?;
        }

        Ok(())
    }

    /// Build a global index mapping item paths to their crate and URL.
    fn build_global_index(&self) -> GlobalItemIndex {
        let mut index = GlobalItemIndex::default();

        for (crate_name, krate) in &self.crates {
            for (id, summary) in &krate.paths {
                // Only index items from this crate (crate_id 0 means local).
                if summary.crate_id == 0 {
                    let path = summary.path.join("::");
                    index.items.insert(path.clone(), ItemLocation {
                        crate_name: crate_name.clone(),
                        path: summary.path.clone(),
                        kind: summary.kind,
                    });
                }
            }
        }

        index
    }
}

/// Global index of items across all crates.
#[derive(Debug, Default)]
pub struct GlobalItemIndex {
    /// Map from full path (like "serde::Serialize") to item location.
    pub items: HashMap<String, ItemLocation>,
}

/// Location of an item in the documentation.
#[derive(Debug, Clone)]
pub struct ItemLocation {
    /// The crate this item belongs to.
    pub crate_name: String,
    /// Path components (e.g., ["serde", "Serialize"]).
    pub path: Vec<String>,
    /// The kind of item.
    pub kind: rustdoc_types::ItemKind,
}
