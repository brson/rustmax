use std::process::Command;
use std::env;

#[test]
fn test_binary_help() {
    let output = Command::new(get_binary_path())
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Rustmax Suite"));
    assert!(stdout.contains("Available commands:"));
    assert!(stdout.contains("Modular architecture successfully created!"));
}

#[test]
fn test_binary_greet_command() {
    let output = Command::new(get_binary_path())
        .args(&["greet", "Alice"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Hello, Alice!"));
}

#[test]
fn test_binary_greet_no_name() {
    let output = Command::new(get_binary_path())
        .args(&["greet"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Hello, World!"));
}

#[test]
fn test_binary_greet_long_name() {
    let output = Command::new(get_binary_path())
        .args(&["greet", "VeryLongNameThatExceedsTwentyCharacters"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Hello, VeryLongNameThatE...!"));
}

#[test]
fn test_binary_count_command() {
    let output = Command::new(get_binary_path())
        .args(&["count", "5"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Counting to 5: 1, 2, 3, 4, 5"));
}

#[test]
fn test_binary_count_zero() {
    let output = Command::new(get_binary_path())
        .args(&["count", "0"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Nothing to count"));
}

#[test]
fn test_binary_count_large_number() {
    let output = Command::new(get_binary_path())
        .args(&["count", "150"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Too big to count"));
}

#[test]
fn test_binary_math_command() {
    let output = Command::new(get_binary_path())
        .args(&["math", "10", "5"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Math operations on 10 and 5:"));
    assert!(stdout.contains("Add: 15"));
    assert!(stdout.contains("Multiply: 50"));
    assert!(stdout.contains("Divide: 2"));
}

#[test]
fn test_binary_math_divide_by_zero() {
    let output = Command::new(get_binary_path())
        .args(&["math", "10", "0"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Cannot divide by zero"));
}

#[test]
fn test_binary_internal_tests() {
    let output = Command::new(get_binary_path())
        .args(&["test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Running internal tests..."));
    assert!(stdout.contains("All internal tests passed!"));
}

#[test]
fn test_binary_unknown_command() {
    let output = Command::new(get_binary_path())
        .args(&["unknown"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Unknown command"));
    assert!(stdout.contains("Available commands:"));
}

#[test]
fn test_binary_file_command() {
    let output = Command::new(get_binary_path())
        .args(&["file", "test content"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("File operations:"));
    assert!(stdout.contains("matches: true"));
}

#[test]
fn test_binary_parse_command() {
    let output = Command::new(get_binary_path())
        .args(&["parse", "--name", "Test", "--count", "5", "--verbose"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("CLI parsing with clap:"));
    assert!(stdout.contains("name=Test"));
    assert!(stdout.contains("count=5"));
    assert!(stdout.contains("verbose=true"));
}

#[test]
fn test_binary_serialize_json() {
    let output = Command::new(get_binary_path())
        .args(&["serialize", "json"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Serialization test with json:"));
    assert!(stdout.contains("JSON roundtrip successful"));
}

#[test]
fn test_binary_serialize_toml() {
    let output = Command::new(get_binary_path())
        .args(&["serialize", "toml"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Serialization test with toml:"));
    assert!(stdout.contains("TOML roundtrip successful"));
}

#[test]
fn test_binary_crypto_blake3() {
    let output = Command::new(get_binary_path())
        .args(&["crypto", "blake3", "hello"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Cryptographic test with blake3:"));
    assert!(stdout.contains("BLAKE3 hash of 'hello'"));
}

#[test]
fn test_binary_crypto_sha256() {
    let output = Command::new(get_binary_path())
        .args(&["crypto", "sha256", "test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Cryptographic test with sha256:"));
    assert!(stdout.contains("SHA256 hash of 'test'"));
}

#[test]
fn test_binary_time_chrono() {
    let output = Command::new(get_binary_path())
        .args(&["time", "chrono", "now"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Date/time test with chrono:"));
    assert!(stdout.contains("Current UTC time:"));
}

#[test]
fn test_binary_time_jiff() {
    let output = Command::new(get_binary_path())
        .args(&["time", "jiff", "now"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Date/time test with jiff:"));
    assert!(stdout.contains("Current timestamp:"));
}

#[test]
fn test_binary_regex_command() {
    let output = Command::new(get_binary_path())
        .args(&["regex", r"\w+", "hello world"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Regex test:"));
    assert!(stdout.contains("2 matches"));
    assert!(stdout.contains("First: 'hello'"));
}

#[test]
fn test_binary_async_futures() {
    let output = Command::new(get_binary_path())
        .args(&["async", "futures", "3"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Async/futures test with futures:"));
    assert!(stdout.contains("Ran 3 async futures"));
}

#[test]
fn test_binary_async_spawn() {
    let output = Command::new(get_binary_path())
        .args(&["async", "spawn", "4"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Async/futures test with spawn:"));
    assert!(stdout.contains("Spawned 4 tasks"));
}

#[test]
fn test_binary_parallel_map() {
    let output = Command::new(get_binary_path())
        .args(&["parallel", "map", "100"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Parallel processing test with map:"));
    assert!(stdout.contains("Parallel map on 100 items"));
}

#[test]
fn test_binary_parallel_filter() {
    let output = Command::new(get_binary_path())
        .args(&["parallel", "filter", "100"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Parallel processing test with filter:"));
    assert!(stdout.contains("50 even numbers"));
}

#[test]
fn test_binary_util_itertools() {
    let output = Command::new(get_binary_path())
        .args(&["util", "itertools"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Utility crates test with itertools:"));
    assert!(stdout.contains("cartesian:"));
}

#[test]
fn test_binary_util_bytes() {
    let output = Command::new(get_binary_path())
        .args(&["util", "bytes", "test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Utility crates test with bytes:"));
    assert!(stdout.contains("Bytes - len:"));
}

#[test]
fn test_binary_util_bigint() {
    let output = Command::new(get_binary_path())
        .args(&["util", "bigint", "123"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Utility crates test with bigint:"));
    assert!(stdout.contains("BigInt - a: 123"));
}

#[test]
fn test_binary_util_semver() {
    let output = Command::new(get_binary_path())
        .args(&["util", "semver", "2.0.0"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Utility crates test with semver:"));
    assert!(stdout.contains("Semver - v1: 2.0.0"));
}

#[test]
fn test_binary_util_base64() {
    let output = Command::new(get_binary_path())
        .args(&["util", "base64", "hello"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Utility crates test with base64:"));
    assert!(stdout.contains("roundtrip: true"));
}

#[test]
fn test_binary_walk_command() {
    let output = Command::new(get_binary_path())
        .args(&["walk", "src", "1"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Directory walk test:"));
    assert!(stdout.contains("Walked 'src'"));
}

#[test]
fn test_binary_rand_generate() {
    let output = Command::new(get_binary_path())
        .args(&["rand", "generate", "3"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Random number test with generate:"));
    assert!(stdout.contains("Generated 3 random numbers"));
}

#[test]
fn test_binary_rand_shuffle() {
    let output = Command::new(get_binary_path())
        .args(&["rand", "shuffle", "4"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Random number test with shuffle:"));
    assert!(stdout.contains("Shuffled 1-4"));
}

#[test]
fn test_binary_rand_types() {
    let output = Command::new(get_binary_path())
        .args(&["rand", "types", "2"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Random number test with types:"));
    assert!(stdout.contains("Random types:"));
}

#[test]
fn test_binary_url_parse() {
    let output = Command::new(get_binary_path())
        .args(&["url", "parse", "https://example.com:8080/path?q=test#frag"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("URL test with parse:"));
    assert!(stdout.contains("scheme='https'"));
    assert!(stdout.contains("host=Some(\"example.com\")"));
}

#[test]
fn test_binary_url_manipulate() {
    let output = Command::new(get_binary_path())
        .args(&["url", "manipulate", "http://test.com/old"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("URL test with manipulate:"));
    assert!(stdout.contains("Modified URL:"));
}

#[test]
fn test_binary_url_validate() {
    let output = Command::new(get_binary_path())
        .args(&["url", "validate", "https://valid.example.com"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("URL test with validate:"));
    assert!(stdout.contains("URL validation:"));
}

#[test]
fn test_binary_nom_numbers() {
    let output = Command::new(get_binary_path())
        .args(&["nom", "numbers", "42 123 7"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Parser combinators test with numbers:"));
    assert!(stdout.contains("Parsed numbers: [42, 123, 7]"));
    assert!(stdout.contains("sum: 172"));
}

#[test]
fn test_binary_nom_email() {
    let output = Command::new(get_binary_path())
        .args(&["nom", "email", "user@test.com"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Parser combinators test with email:"));
    assert!(stdout.contains("Parsed email: user='user'"));
    assert!(stdout.contains("domain='test.com'"));
}

#[test]
fn test_binary_nom_json() {
    let output = Command::new(get_binary_path())
        .args(&["nom", "json_simple", r#"{"name": "test", "count": 42}"#])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Parser combinators test with json_simple:"));
    assert!(stdout.contains("Parsed JSON pairs:"));
}

#[test]
fn test_binary_thiserror_validation() {
    let output = Command::new(get_binary_path())
        .args(&["thiserror", "validation", "invalid data"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Custom error handling test with validation:"));
    assert!(stdout.contains("Created validation error: Validation failed: invalid data"));
}

#[test]
fn test_binary_thiserror_chain() {
    let output = Command::new(get_binary_path())
        .args(&["thiserror", "chain", "test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Custom error handling test with chain:"));
    assert!(stdout.contains("Error chaining example:"));
}

#[test]
fn test_binary_thiserror_result() {
    let output = Command::new(get_binary_path())
        .args(&["thiserror", "result", "success"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Custom error handling test with result:"));
    assert!(stdout.contains("Operation succeeded: Success!"));
}

#[test]
fn test_binary_xshell_info() {
    let output = Command::new(get_binary_path())
        .args(&["xshell", "info"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Shell execution test with info:"));
    assert!(stdout.contains("Shell info: current directory ="));
}

#[test]
fn test_binary_xshell_echo() {
    let output = Command::new(get_binary_path())
        .args(&["xshell", "echo", "Hello xshell"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Shell execution test with echo:"));
    assert!(stdout.contains("Echo output: 'Hello xshell'"));
}

#[test]
fn test_binary_xshell_pwd() {
    let output = Command::new(get_binary_path())
        .args(&["xshell", "pwd"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Shell execution test with pwd:"));
    assert!(stdout.contains("Current directory:"));
}

#[test]
fn test_binary_crossbeam_channel() {
    let output = Command::new(get_binary_path())
        .args(&["crossbeam", "channel", "3"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Advanced concurrency test with channel:"));
    assert!(stdout.contains("Channel demo: Sent 3 messages, received 3 messages"));
}

#[test]
fn test_binary_crossbeam_scope() {
    let output = Command::new(get_binary_path())
        .args(&["crossbeam", "scope", "4"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Advanced concurrency test with scope:"));
    assert!(stdout.contains("Scoped threads demo:"));
}

#[test]
fn test_binary_crossbeam_deque() {
    let output = Command::new(get_binary_path())
        .args(&["crossbeam", "deque", "5"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Advanced concurrency test with deque:"));
    assert!(stdout.contains("Work-stealing deque: pushed=5"));
}

#[test]
fn test_binary_tempfile_create() {
    let output = Command::new(get_binary_path())
        .args(&["tempfile", "create", "hello tempfile"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Temporary file operations test with create:"));
    assert!(stdout.contains("Created anonymous tempfile, wrote 14 bytes"));
    assert!(stdout.contains("read back: 'hello tempfile'"));
}

#[test]
fn test_binary_tempfile_named() {
    let output = Command::new(get_binary_path())
        .args(&["tempfile", "named", "test data"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Temporary file operations test with named:"));
    assert!(stdout.contains("Created named tempfile at"));
    assert!(stdout.contains("content: 'test data'"));
}

#[test]
fn test_binary_tempfile_dir() {
    let output = Command::new(get_binary_path())
        .args(&["tempfile", "dir", "directory test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Temporary file operations test with dir:"));
    assert!(stdout.contains("Created tempdir"));
    assert!(stdout.contains("wrote file with content: 'directory test'"));
}

#[test]
fn test_binary_json5_parse() {
    let output = Command::new(get_binary_path())
        .args(&["json5", "parse", "{name: 'test', value: 42}"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("JSON5 relaxed parsing test with parse:"));
    assert!(stdout.contains("JSON5 parsed successfully:"));
    assert!(stdout.contains(r#"{"name":"test","value":42}"#));
}

#[test]
fn test_binary_json5_comments() {
    let output = Command::new(get_binary_path())
        .args(&["json5", "comments"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("JSON5 relaxed parsing test with comments:"));
    assert!(stdout.contains("JSON5 with comments parsed:"));
}

#[test]
fn test_binary_json5_trailing() {
    let output = Command::new(get_binary_path())
        .args(&["json5", "trailing"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("JSON5 relaxed parsing test with trailing:"));
    assert!(stdout.contains("JSON5 with trailing commas:"));
}

#[test]
fn test_binary_tera_render() {
    let output = Command::new(get_binary_path())
        .args(&["tera", "render", "Alice"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Template engine test with render:"));
    assert!(stdout.contains("Template rendered: 'Hello Alice! Welcome to Rustmax Suite.'"));
}

#[test]
fn test_binary_tera_loops() {
    let output = Command::new(get_binary_path())
        .args(&["tera", "loops"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Template engine test with loops:"));
    assert!(stdout.contains("Loop template: 'Items: apple, banana, cherry'"));
}

#[test]
fn test_binary_tera_filters() {
    let output = Command::new(get_binary_path())
        .args(&["tera", "filters", "Test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Template engine test with filters:"));
    assert!(stdout.contains("Original: Test | Upper: TEST | Length: 4"));
}

#[test]
fn test_binary_unicode_graphemes() {
    let output = Command::new(get_binary_path())
        .args(&["unicode", "graphemes", "Hello ðŸŒ World!"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Unicode text segmentation test with graphemes:"));
    assert!(stdout.contains("Graphemes:"));
    assert!(stdout.contains("total"));
}

#[test]
fn test_binary_unicode_words() {
    let output = Command::new(get_binary_path())
        .args(&["unicode", "words", "Hello world! This is a test."])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Unicode text segmentation test with words:"));
    assert!(stdout.contains("Words:"));
}

#[test]
fn test_binary_unicode_compare() {
    let output = Command::new(get_binary_path())
        .args(&["unicode", "compare"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Unicode text segmentation test with compare:"));
    assert!(stdout.contains("Simple 'Hello World'"));
    assert!(stdout.contains("graphemes"));
}

#[test]
fn test_binary_logging_levels() {
    let output = Command::new(get_binary_path())
        .args(&["logging", "levels", "test message"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Logging infrastructure test with levels:"));
    assert!(stdout.contains("Logged 'test message' at all levels"));
}

#[test]
fn test_binary_logging_init() {
    let output = Command::new(get_binary_path())
        .args(&["logging", "init"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Logging infrastructure test with init:"));
    assert!(stdout.contains("Logger initialized with RUST_LOG=debug"));
}

#[test]
fn test_binary_logging_performance() {
    let output = Command::new(get_binary_path())
        .args(&["logging", "performance", "perf test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Logging infrastructure test with performance:"));
    assert!(stdout.contains("Performance logging: 10 debug messages"));
}

#[test]
fn test_binary_proptest_basic() {
    let output = Command::new(get_binary_path())
        .args(&["proptest", "basic", "10"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Property-based testing with basic:"));
    assert!(stdout.contains("Commutative addition property:"));
    assert!(stdout.contains("tests passed"));
}

#[test]
fn test_binary_proptest_string() {
    let output = Command::new(get_binary_path())
        .args(&["proptest", "string", "15"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Property-based testing with string:"));
    assert!(stdout.contains("String reverse property:"));
}

#[test]
fn test_binary_proptest_collection() {
    let output = Command::new(get_binary_path())
        .args(&["proptest", "collection", "12"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Property-based testing with collection:"));
    assert!(stdout.contains("Collection sort properties:"));
}

#[test]
fn test_binary_proptest_roundtrip() {
    let output = Command::new(get_binary_path())
        .args(&["proptest", "roundtrip", "8"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Property-based testing with roundtrip:"));
    assert!(stdout.contains("JSON roundtrip property:"));
}

#[test]
fn test_binary_proptest_invariant() {
    let output = Command::new(get_binary_path())
        .args(&["proptest", "invariant", "10"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Property-based testing with invariant:"));
    assert!(stdout.contains("Invariant testing:"));
}

#[test]
fn test_binary_anyhow_basic() {
    let output = Command::new(get_binary_path())
        .args(&["anyhow", "basic", "success test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Error handling with anyhow using basic:"));
    assert!(stdout.contains("Basic anyhow success:"));
}

#[test]
fn test_binary_anyhow_context() {
    let output = Command::new(get_binary_path())
        .args(&["anyhow", "context", "test"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Error handling with anyhow using context:"));
    assert!(stdout.contains("Context chain:"));
}

#[test]
fn test_binary_anyhow_conversion() {
    let output = Command::new(get_binary_path())
        .args(&["anyhow", "conversion", "42"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("Error handling with anyhow using conversion:"));
    assert!(stdout.contains("Conversion success:"));
}

#[test]
fn test_binary_reqwest_client() {
    let output = Command::new(get_binary_path())
        .args(&["reqwest", "client"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("HTTP client operations with client:"));
    assert!(stdout.contains("Client created successfully"));
}

#[test]
fn test_binary_reqwest_get() {
    let output = Command::new(get_binary_path())
        .args(&["reqwest", "get", "https://httpbin.org/json"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("HTTP client operations with get:"));
    // This might fail if no network access, so we check for either success or failure
    assert!(stdout.contains("GET request") && (stdout.contains("successful") || stdout.contains("failed")));
}

#[test]
fn test_binary_reqwest_json() {
    let output = Command::new(get_binary_path())
        .args(&["reqwest", "json", "https://httpbin.org/json"])
        .output()
        .expect("Failed to execute binary");

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert!(stdout.contains("HTTP client operations with json:"));
    // Check for either JSON response or request failure
    assert!(stdout.contains("JSON") && (stdout.contains("response") || stdout.contains("failed")));
}

fn get_binary_path() -> String {
    // Check if we're running under cargo-llvm-cov
    if env::var("CARGO_LLVM_COV").is_ok() {
        // Use the llvm-cov instrumented binary
        let target_dir = env::var("CARGO_LLVM_COV_TARGET_DIR")
            .unwrap_or_else(|_| "target/llvm-cov-target".to_string());

        // Check for custom profile first, then fallback to debug/release
        let profile = env::var("CARGO_PROFILE")
            .unwrap_or_else(|_| {
                if cfg!(debug_assertions) {
                    "debug".to_string()
                } else {
                    "release".to_string()
                }
            });

        let binary_path = format!("{}/{}/rmx-suite-simple", target_dir, profile);

        // If custom profile binary doesn't exist, try debug fallback
        if !std::path::Path::new(&binary_path).exists() {
            let debug_path = format!("{}/debug/rmx-suite-simple", target_dir);
            if std::path::Path::new(&debug_path).exists() {
                return debug_path;
            }
            // Also try coverage profile explicitly
            let coverage_path = format!("{}/coverage/rmx-suite-simple", target_dir);
            if std::path::Path::new(&coverage_path).exists() {
                return coverage_path;
            }
        }

        binary_path
    } else {
        // Use the normal binary
        let target_dir = env::var("CARGO_TARGET_DIR")
            .unwrap_or_else(|_| "target".to_string());

        let profile = if cfg!(debug_assertions) {
            "debug"
        } else {
            "release"
        };

        format!("{}/{}/rmx-suite-simple", target_dir, profile)
    }
}